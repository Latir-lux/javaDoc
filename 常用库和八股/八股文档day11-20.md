# 八股训练营

## Day11

### Case1

#### 题目：进程调度算法你了解多少

**答案：**

进程调度算法一般指的是**单核CPU**系统中的调度算法。调度的进程大致可以分为两类，一类是**计算密集型**，一类是**I/O密集型**，前者占用CPU时间较长，后者更多时间用于I/O通信，占用CPU时间较短。

- **先来先服务**：**非抢占式**的调度算法，按照请求的顺序进行调度。 这种调度方式简单，但是可能导致长作业阻塞短作业。
- **最短作业优先**：**非抢占式**的调度算法，系统会**估计**作业所需要的运行时间，优先调用短作业。 但是如果一直有短作业到来，会造成长作业“饥饿”现象。
- **最短剩余时间优先**：基于最短作业优先改进，按**剩余运行时间**判断优先级。当一个新的作业到达时，将其运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。也有可能导致长作业“饥饿”现象。
- **高响应比优先调度**：高响应比优先的主要目的是**权衡短作业和长作业**，响应比的计算公式是**(等待时间 + 剩余运行时间) / 剩余运行时间**，算法会根据公式得到的优先级来调度。
- **时间片轮转调度**：对每个进程**一视同仁**，为每个进程分配一个时间片，进程轮流执行，时间片用完后切换到下一个进程。注意时间片太短会导致过多上下文切换，降低效率，过长会导致短作业进程等待时间变长。
- **优先级调度**：进程的优先级可以分为**静态优先级**和**动态优先级**，前者在进程创建时确定，后者会根据进程情况**动态调整**，比如运行时间增加会降低优先级，等待时间增加会升高优先级。算法会按优先级进行调度，处理方式可以分为抢占式和非抢占式。
- **多级反馈队列**：结合了**时间片轮转调度**算法和**优先级调度**算法。 将进程分为不同的优先级队列，每个队列内部有自己的调度算法，各个队列有自己的时间片用于执行进程。一个进程在当前队列没有执行完，会进入下一个优先级的队列继续等待。

详细内容参考：

[5.1 进程、线程基础知识 | 小林coding](https://xiaolincoding.com/os/4_process/process_base.html#调度算法)

[【操作系统】CPU调度算法_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Kz4y117gZ/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

### Case2

#### 题目：进程间有哪些通信方式

**答案：**

1. **管道**：所有管道的数据传输都是**单向**的，而且遵循**先进先出**的原则。

   - **匿名**管道：Linux命令中有一个`|`，它就是一个管道，作用是将左侧命令的输出作为右侧命令的输入，这种管道没有名字，所以被称为**匿名管道**，会随着进程结束销毁，且通信范围是存在**父子关系的进程**。
   - **命名**管道：如果在创建管道的时候指定名字，那就是命名管道，与管道类似，但是通信范围可以是**两个不相关的进程**。

   管道的优势在于**简单**，但是**通信效率很低**，不适合频繁交换数据。

2. **消息队列**：消息队列是保存在内核中的**消息链表**，发送方将输入放入对应队列后就可以正常返回了，在接收方读取后，会从队列中删除这个消息体。因为队列保存在**内核**中，所以过程中会发生**用户态和内核态之间**拷贝数据。
   消息队列的优点是通信效率相对管道高，缺点在于通信不及时，也不适合大数据量的传输。

3. **共享内存**：消息队列中，会发生用户态和内核态之间消息拷贝的情况，共享内存解决了这一问题。共享内存的机制是**拿出一块虚拟地址空间，映射到相同的物理内存中**，多个进程都可以访问。由于不需要数据拷贝，共享内存是**最快**的进程通信方式。

4. **信号量**：共享内存的通信方式会带来新的问题，如果多个进程**同时修改**同一个共享内存，先写的内容可能会被覆盖。为了防止进程竞争资源，信号量实现了一种锁机制，让**任意时刻某个资源只能被一个进程访问**。信号量表示资源的数量，控制方式有两种原子操作：

   - **P操作**：将信号量减一，表示占用一个资源，资源量不足时会使进程阻塞等待。
   - **V操作**：将信号量加一，表示释放一个资源。

   P操作和V操作必须成对出现。

5. **信号**：前面几种进程间通信，都是常规状态下的工作模式，对于**异常情况**下的工作模式，需要用**信号**的方式来通知进程。Linux系统中提供了几十种信号，分别代表不同的意义。
   信号是进程间通信机制中唯一一种**异步通信机制**，可以在任何时候发送信号给某一进程。对于信号的处理方式有以下几种：

   1. **执行默认操作**：Linux对每种信号都规定了默认操作。
   2. **捕捉信号**：可以定义一个信号处理函数，接收信号后执行函数。
   3. **忽略信号**：其中`SIGKILL`和`SEGSTOP`是无法捕捉和忽略的。

6. **Socket**：以上的机制都是在同一台主机上通信，如果需要**跨网络与不同主机的进程通信**，需要使用Socket，要绑定**IP地址和端口**。如果用于本地通信，则需要绑定**本地文件**。

详细内容参考：

[5.2 进程间有哪些通信方式？ | 小林coding](https://xiaolincoding.com/os/4_process/process_commu.html#管道)

[大厂面试笔试题31丨进程间通信方式_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1tv411p7WX/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

[『面试问答』：进程间通信的方式有哪些？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1oX4y177y7/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

### Case3

#### 题目：解释一下进程同步和互斥，以及如何实现进程同步和互斥

**答案：**

进程**同步**指的是多个并发进程在一些关键点上可能需要互相等待或者互通消息，以确保他们**按照一定顺序或者时间间隔执行**。

进程**互斥**指的是，在多个进程需要访问同一个资源时，他们之间是**竞争关系**，可能在操作同一个变量时发生上下文切换等导致结果错误。我们把访问资源的这一段代码称为**临界区**，互斥就是保证临界区每次**最多出现一个**进程。

解决进程同步和互斥的问题有很多种方法，其中一种常见的方法是使用**信号量和 PV 操作**。信号量表示系统中某种资源的数量或者状态。PV 操作是用于操作信号量的**原子操作**。

- **P操作**：相当于“占用”信号量，如果资源可用，就减少信号量计数，然后使用资源。
- **V操作**：相当于“归还”资源，增加信号量的计数，并可能唤醒等待的进程。

除此之外，下面的方法也可以解决进程同步和互斥问题：

- **临界区**：将可能引发互斥问题的代码段称为临界区，里面包含了需要互斥访问的资源。进入这个区域前需要先获取锁，退出临界区后释放该锁。这确保同一时间只有一个进程可以进入临界区。
- **互斥锁（Mutex）**：将每个共享资源都关联一个互斥锁，进程在访问该资源前需要先获取互斥锁，使用完后释放锁。只有获得锁的进程才能访问共享资源。
- **条件变量**：条件变量用于在进程之间传递信息，通常与互斥锁一起使用。互斥锁只有锁定和非锁定两种状态，而条件变量可以**允许线程阻塞和等待其他线程的消息**，弥补了互斥锁的不足。

详细内容参考：

[5.3 多线程冲突了怎么办？ | 小林coding](https://xiaolincoding.com/os/4_process/multithread_sync.html#竞争与协作)

## Day12

### Case1

#### 题目：什么是死锁，如何避免死锁？

**答案：**

死锁是系统的多个进程在执行过程中，因争夺资源而造成的一种**僵局**。当每个进程都**持有一定的资源**并**等待其他进程释放它们所需的资源**时，如果所有进程都不释放资源，就导致了**死锁**。

死锁只有同时满足以下四个条件才会发生：

- **互斥条件**：多个进程不能同时使用同一个资源。
- **持有并等待条件**：一个进程因为请求资源而被阻塞的时候，不会释放自己持有的资源。
- **不可剥夺条件**：一个进程持有的资源只能由自己主动释放，不能被强制性的剥夺。
- **环路等待条件**：多个进程获取资源的顺序构成了环形链，每个进程都在等待下一个进程所占有的资源。

避免死锁有以下几种方法：

1. 避免死锁：**避免死锁的常见方法就是破坏其中一个条件**。最常见并且可行的就是**使用资源有序分配法破坏环路等待条件**。也就是说如果有多个进程需要获取相同的几个资源，他们获取这几个资源的**顺序必须是一致**的，就可以打破死锁。
2. 检测死锁：通过检测系统中的资源分配情况来判断是否存在死锁。比如，可以使用**资源分配图**或**银行家算法**进行检测。
3. 解除死锁：一旦检测到死锁存在，可以采取一些措施来解除死锁。比如，可以通过抢占资源、终止某些进程或进行资源回收等方式来解除死锁。

详细内容参考：

[5.4 怎么避免死锁？ | 小林coding](https://xiaolincoding.com/os/4_process/deadlock.html#死锁的概念)

### Case2

#### 题目：介绍一下几种典型的锁

**答案：**

最基本的两种锁是**互斥锁和自旋锁**，加锁的目的在于保证共享资源在任意时间里，只有一个线程访问，可以防止数据错误。如果当前资源有一个线程加锁之后，其他线程加锁就会失败，互斥锁和自旋锁对于**加锁失败**的处理方式是不同的。

- **互斥锁**：互斥锁加锁失败之后，线程会**释放CPU**进入阻塞状态。
- **自旋锁**：自旋锁加锁失败后，线程会**忙等待**，即线程在尝试获取锁时会**不断轮询**，直到拿到锁。

互斥锁会增加两次上下文切换的成本，如果被锁定的代码**执行时间短**，优先使用自旋锁。

其他的锁都是基于上面这两个锁的

- **读写锁**：分为**读锁**和**写锁**两部分，用于明确区分读和写两种场景。当写锁没有被线程持有时，多个线程可以并发地持有读锁，一旦**写锁**被持有，获取**读锁和写锁**的操作都会被阻塞。提高了共享资源的访问效率，适用于**读多写少**的场景。
  上述情况容易出现读线程饥饿，所以有一种**公平读写锁**，读线程和写线程都按照先进先出的方式加锁。
- **悲观锁**：之前的互斥锁、自旋锁、读写锁都是悲观锁，他认为多线程同时修改共享资源的概率比较高，容易出现冲突，所以访问共享资源前必须先上锁。
- **乐观锁**：选择**先修改**共享资源，再验证这段时间有没有**其他线程在修改**资源，如果没有，操作完成，如果有就放弃本次操作。乐观锁全程没有加锁，可以叫无锁编程，只有在**冲突概率低**，并且**加锁成本高**时使用。

详细内容参考：

[5.5 什么是悲观锁、乐观锁？ | 小林coding](https://xiaolincoding.com/os/4_process/pessim_and_optimi_lock.html#互斥锁与自旋锁)

### Case3

#### 题目：讲一讲你理解的虚拟内存

**答案：**

随着计算机的发展，我们运行程序时需要加载的数据是越来越大的，**内存**中逐渐**放不下**这些数据了，那么我们的选择就是将部分数据存放在**硬盘**中，需要的时候加载到内存里，同样的，内存中有部分用不到的数据，也会被移到硬盘中。

这个过程中，为了不影响程序的运行，我们提出了**虚拟内存地址**和**物理内存地址**两个概念，前者是程序所使用的内存地址，后者是硬件中实际存在的地址，两者之间的映射关系使用**内存管理单元（MMU）**来管理，程序运行时会分配一个**连续的虚拟地址空间**，让程序认为他有**足够的空间**来运行。

虚拟内存的**功能**：

- **内存扩展**：虚拟内存使得每个程序都可以使用**比实际可用内存更大**的空间。
- **内存隔离**：虚拟内存还提供了进程之间的内存隔离，一个进程无法直接访问另一个进程的内存。
- **物理内存管理**：也就是前面提到的，虚拟内存允许操作系统**动态地**将数据和程序的部分加载到物理内存中，当物理内存**不足**时，操作系统可以将不常用的数据或程序暂时移到硬盘上，从而释放内存。
- **内存映射文件**：虚拟内存可以将文件映射到内存中，可以让文件的读取和写入像访问内存一样高效。

上述功能中的**物理内存管理**的实现主要依靠以下几种方法：

- **内存分段**：分段机制下的地址由**段选择因子**和**段内偏移量**组成。前者用作段表的索引，找到**段的基地址和界限**，后者用于定位具体地址。
- **内存分页**：分页机制把整个虚拟和物理内存空间分割成多个固定大小的页，使用**内存管理单元（MMU）**来管理两者之间的映射关系。还引申出了**多级页表**等形式。
- **段页式管理**：结合了上述两种方法，地址由**段号**、**段内页号**和**页内位移**三部分组成。

详细内容参考：

[4.1 为什么要有虚拟内存？ | 小林coding](https://xiaolincoding.com/os/3_memory/vmem.html#虚拟内存)

[【操作系统】内存管理——虚拟内存_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV18v411a7Vk/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

## Day13

### Case1

#### 题目：你知道的线程同步的方式有哪些？

**答案：**

线程同步机制是指在多线程编程中，为了保证原本**异步的**线程之间的互不干扰，能够**有序执行**的一种机制。常见的线程同步机制有以下几种：

1. **锁**：锁是最常见的线程同步机制，加锁的目的在于保证共享资源在任意时间里，只有一个线程访问，可以协调线程同步。主要有以下几种锁：
   - **互斥锁&自旋锁**：共享资源每次只能有一个线程加锁，之后其他线程再加锁会失败，互斥锁和自旋锁对加锁失败的处理方式不同：**互斥锁**会让线程释放CPU进入**阻塞**状态；**自旋锁**会让线程**忙等待**，也就是自旋锁会不停的**轮询**直到拿到锁。
   - **读写锁**：分为**读锁**和**写锁**两部分，用于明确区分读和写两种场景。当写锁没有被线程持有时，多个线程可以并发地持有读锁，一旦**写锁**被持有，获取**读锁和写锁**的操作都会被阻塞。
2. **条件变量**：条件变量用于**线程间通信**，允许一个线程再某个条件成立前等待，条件满足后再继续执行。通常与互斥锁一起使用。
3. **信号量**：解决线程同步问题最常见的方法是使用**信号量和 PV 操作**。信号量表示系统中某种资源的数量或者状态。PV 操作是用于操作信号量的**原子操作**。
   - **P操作**：相当于“占用”信号量，如果资源可用，就减少信号量计数，然后使用资源。
   - **V操作**：相当于“归还”资源，增加信号量的计数，并可能唤醒等待的进程。

 详细内容参考：

[多线程编程：一次性搞懂线程同步机制_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1oQ4y1C73G/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

[『面试问答』：线程间同步方式有哪些？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV19m4y1N7VK/?share_source=copy_web&vd_source=db4b8256b37979f4e7f296b129aaaf87)

### Case2

#### 题目：有哪些页面置换算法

**答案：**

在说明页面置换算法前，首先说明一下**缺页中断**。当CPU访问的页面不存在物理页面时，就会产生缺页中断，会请求操作系统将缺少的页面调入物理内存。一般的中断会在一条**指令执行完成后**处理，而缺页中断在**指令执行期间**内就需要进行处理，因为它涉及底层硬件，比较严重。
在处理过程中，如果内存还有**空闲页**，直接将物理页载入，否则就需要利用**页面置换算法**，选择一个物理页面，将内存中的页面和磁盘中的页面进行置换。

常见页面置换算法有最佳置换算法（OPT）、先进先出（FIFO）、最近最久未使用算法（LRU）、时钟算法（Clock）、最不经常使用算法（LFU）等。

1. **最佳置换算法**：核心思想是置换在**未来最长时间不访问**的页面。虽然核心思想很理想，但是会有一个问题，操作系统不可能清楚**未来会访问的页面**，所以这种算法只是一种理想情况下的置换算法，通常是无法实现的。
2. **先进先出`FIFO`算法**：选择**最先进入内存**的页面，也就是在内存**驻留时间最长**的页面进行置换。
3. **最近最久未使用算法`LRU`** ：通过记录页面的**使用历史**，选择**最长时间未被访问**的页面进行置换。也就是说这个算法的假设是，很长时间未被访问的页面在未来很长时间也不会被使用。
4. **时钟算法`CLOCK`**：核心思想是使用一个指针（称为时钟指针）在**环形链表**上遍历，检查页面是否被访问过的同时选择被置换的页面。 是否被访问过使用**访问位**来标记，**0为未被访问**。缺页中断后，指针从当前位置开始查找：
   - 如果一个页面的**访问位为0**，将该页面与新的页面置换，指针向前移动。
   - 如果访问位为1，将访问位置0，指针向前移动。
5. **最不经常使用`LFU`**：在每个页面中设置一个**访问计数器**，缺页中断时淘汰**访问次数最少**的页面。

详细内容参考：

[6.1 进程调度/页面置换/磁盘调度算法 | 小林coding](https://xiaolincoding.com/os/5_schedule/schedule.html#内存页面置换算法)

[【操作系统】10分钟-速解页面置换算法_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Hb4y1J7dD/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

## Day15

### Case1

#### 题目：熟悉哪些Linux命令

**答案**：

1. **文件操作**：
   - `ls`：列出目录内容。
   - `cd`：改变当前所在目录。
   - `pwd`：显示当前工作目录。
   - `cp`：复制文件或目录。
   - `mv`：移动或重命名文件。
   - `rm`：删除文件或目录。
   - `touch`：创建空文件或更新文件时间戳。
   - `file`：获取文件相关信息。
2. **文件内容查看**：
   - `cat`：查看文件内容。
   - `head`：查看文件的前几行。
   - `tail`：查看文件的后几行，常用于查看日志文件。
   - `less`：常看文件内容，可以上下翻阅，退出后不会在屏幕留下内容
   - `more`：常看文件内容，在Linux上只能向下翻阅，退出后在屏幕上留下内容
3. **文件编辑**：
   - `vi` 或 `vim`：一个文本编辑器。
4. **权限管理**：
   - `chmod`：更改文件或目录的访问权限。
   - `chown`：更改文件或目录的所有者和/或所属组。
5. **磁盘管理**：
   - `df`：查看磁盘空间使用情况。
6. **网络管理**：
   - `ifconfig` 或 `ip addr`：查看和配置网络接口。
   - `ping`：测试网络连接。
   - `netstat`：查看网络状态和统计信息。
   - `ssh`：安全远程登录。
7. **进程管理**：
   - `ps`：查看当前运行的进程。
   - `kill`：发送信号给进程。
8. **软件包管理**（根据Linux发行版不同，命令可能有所不同）：
   - `apt-get`（Debian/Ubuntu）：安装、更新和删除软件包。

详细内容参考：

[常用的Linux命令介绍：13个基本命令和Shell脚本编程_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Uv4y127tU/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

### Case2

#### 题目：Linux中如何查看一个进程，如何杀死一个进程，如何查看某个端口有没有被占用

**答案：**

1. **查看进程**：Linux可以使用`ps`或者`top`命令查看当前运行的进程，比如`ps aux`可以列出**所有进程**及其详细信息，`top`可以**实时**查看各个进程的CPU时间**占用的百分比**，默认从上到下占用减少。
2. **杀死进程**：首先用`ps`或`top`命令找到进程的PID（进程ID）。然后用 kill 命令加上进程ID来给进程**发送信号**，比如`kill -9 PID`就会杀死进程。"-9" 是**强制杀死进程**的信号。
3. **查看端口占用**：使用`lsof -i:端口号`可以查看占用特定端口的进程。或者用`netstat -tulnp | grep端口号`，这会显示监听在该端口的服务及其进程ID。

详细信息参考：

[Linux 查看端口占用情况 | 菜鸟教程](https://www.runoob.com/w3cnote/linux-check-port-usage.html)

### Case3

#### 题目：说一下select、poll、epoll

**答案：**

Linux中的**I/O多路复用**是通过调用select、poll、epoll等系统调用来实现的。在Linux中，**一切都被视为文件**，包括网络通信的端口，所以在Linux的I/O操作中，读写操作都通过**文件描述符来**确定对象，在select、poll、epoll中也是如此。

Linux的I/O操作经过了很多次迭代，大致有五种方案，分别是**阻塞I/O**、**非阻塞I/O**、**I/O多路复用**、**信号驱动I/O**、**异步I/O**。其中阻塞I/O和非阻塞I/O都存在**进程切换**和**单进程对单连接**的问题，而I/O多路复用解决了这个问题。

前面提到I/O多路复用通常通过select、poll、epoll等系统调用来实现，下面说明他们的**具体流程**：

- **select**：select监听**多个连接**的方式是fd_set的二进制形式中的每一位来表示一个文件描述符，某一位为1则表示对应的文件描述符已就绪。在服务器启动监听进程时，如果监听的所有socket文件描述符**都没有数据到达**，那么进程进入阻塞状态，同时将进程的**进程描述符和回调函数**合并加入到等待队列中。当网卡接收到数据时，发出中断信号通知CPU有数据到达，CPU执行中断程序将数据写入对应的**数据接收队列**中，并且**唤醒**监听进程。
  select虽然实现了多路复用，但是他的**缺陷**在于：

  - **性能开销大**：1.调用select需要切换用户态和内核态，需要将fd_set在两个状态之间拷贝；2.进程被唤醒后，需要遍历所有fd_set来确定哪个连接收到了数据；3.select只返回就绪文件的个数，确定可读文件还需要遍历。
  - **监听的数量太少**：fd_set在编译内核时就确定了无法更改，一般是1024或者2048 。

- **poll**：解决了select监听数量少的问题。使用**pollfd结构**而非fd_set结构，检查多个文件描述符状态的方式同样是通过轮询，但是因为pollfd**基于链表**，所以没有数量的限制。但是和select一样，面对大量的文件描述符性能会下降。

- **epoll**：解决了性能开销大和监听数量少两个问题，主要特点有

  1. 用**红黑树**存储文件描述符，只需要在添加时传入一次，不用像select一样拷贝；
  2. 通过**异步IO**查找就绪的文件描述符，也就是**事件通知**，而不是轮询；
  3. 用**队列存储**就绪的文件描述符，且直接返回就绪的文件描述符，无需再次遍历。

  epoll的流程和select的区别在于：epoll的epitem对象，包含文件描述符和eventpoll对象指针。把对象的回调函数添加到socket等待队列中，对象插入红黑树，进程则放入**eventpoll等待队列**中。在数据到达时，用epoll_wait函数唤醒eventpoll等待队列中的进程。

**总结**：`select`是最早的 `I/O` 多路复用技术，但受到文件描述符数量和效率方面的限制。`poll`克服了文件描述符数量的限制，但仍然存在一定的效率问题。`epoll`是一种高效的I/O多路复用技术，尤其适用于高并发场景，但它仅在 `Linux` 平台上可用。一般来说，`epoll` 的效率是要比 `select` 和 `poll` 高的，但是对于活动连接较多的时候，由于回调函数触发的很频繁，其效率不一定比 `select` 和 `poll` 高。所以 `epoll` 在连接数量很多，但活动连接较小的情况性能体现的比较明显。

详细内容参考：

[深入学习IO多路复用 select/poll/epoll 实现原理](https://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&mid=2649774761&idx=1&sn=cd93afad37fecb2071d72d7e0dfebf5e&chksm=beccc9d289bb40c4117cdee70f647c72f1f0bf84c71735a5b72f513d6d36a0c427a6070a047d&mpshare=1&scene=1&srcid=0722ngceDqziZ1WKv85ee94u&sharer_shareinfo=78e19e4c66ca592e750f8564805fae5b&sharer_shareinfo_first=78e19e4c66ca592e750f8564805fae5b&version=4.1.6.70203&platform=mac&nwr_flag=1#wechat_redirect)

[Linux IO模式及 select、poll、epoll详解 - 人云思云 - SegmentFault 思否](https://segmentfault.com/a/1190000003063859#item-3-13)

## Day16

### Case1

#### 题目：一条SQL查询语句是如何执行的？

**答案：**

MySQL的架构分为两层：**Server层**和**存储引擎层**：

- **Server层**负责建立连接、分析和执行SQL，MySQL大多数的核心功能模块都在这里实现，主要包括**连接器**、**查询缓存**、**解析器**、**预处理器**、**优化器**、**执行器**等，所有内置函数和跨存储引擎的功能，比如触发器、视图等，也在这一层实现。
- **存储引擎层**中多个不同的存储引擎共用一个Server层，从MySQL5.5开始，InnoDB成为了默认存储引擎，除此以外还有Memory等引擎。

下面是一条SQL查询语句的执行流程：

1. **连接器**：使用MySQL第一步是连接MySQL服务，然后才能执行SQL语句，MySQL基于TCP协议进行传输，建立连接并验证用户名和密码后，**读取该用户权限**，之后的权限逻辑判断都基于此刻读到的权限。

2. **查询缓存**：连接器完成工作之后，客户端开始向MySQL服务发送SQL语句，服务收到之后解析**第一个字段**，用于查看语句的类型。如果是查询语句的话，MySQL先去**查询缓存**中查找缓存数据，数据以**K-V的形式**存储，如果没有命中数据，继续执行，执行完后将结果存入查询缓存。但是实际上在更新频繁的表中命中率很低，因为**表更新后缓存要清空**，所以在MySQL8.0版本后就删除了这个操作。

3. **解析SQL**：执行前，MySQL需要用解析器解析SQL语句，分为两个部分：

   - **词法分析**：从语句中识别出**关键字**。
   - **语法分析**：根据**词法分析的结果**和**语法规则**判断语句是否符合语法，如果没问题构建**语法树**。

   如果输入的SQL语句语法不对，会在解析器阶段报错。

4. **执行SQL**：执行一条查询语句大致可以分为三个部分：

   - **预处理阶段**：通过**预处理器**检查语句中的表或者字段是否存在，如果有`*`符号，把他扩展为表上的所有列。
   - **优化阶段**：通过**优化器**确定查询语句的**执行方案**，比如表里有多个索引的时候，会基于查询成本选择索引，当查询语句时**覆盖索引**时，直接在二级索引可以找到结果，就不需要使用主键索引。
   - **执行阶段**：确定执行方案后，通过**执行器**完成执行，从存储引擎读取记录返回给客户端。

详细内容参考：

[执行一条 select 语句，期间发生了什么？ | 小林coding](https://xiaolincoding.com/mysql/base/how_select.html#mysql-执行流程是怎样的)

### Case2

#### 题目：事务的四大特性有哪些？

**答案：**

事务的四大特性通常被称为 `ACID` 特性：

1. **原子性**：一个事务中的所有操作，要么**全部完成**，要么**全部不完成**，不会在中间环节结束，而且执行过程中发生错误，会被**回滚**到事务开始前的状态。
2. **一致性**：事务操作前和操作后，数据都满足**完整性约束**，数据库保持**一致性状态**。比如说转账前后，发起方和收款方余额总和是一样的。
3. **隔离性**：数据库允许**多个事务同时**对其数据进行读写和修改，隔离性可以防止多个事务并发执行时因为**交叉执行导致数据不一致**，也就是说每个事务都有一个**完整的数据空间**，对其他并发事务是隔离的。
4. **持久性**：事务处理结束后，对数据的修改是**永久的**，系统**故障或崩溃**后也不会丢失。

详细内容参考：

[事务隔离级别是怎么实现的？ | 小林coding](https://xiaolincoding.com/mysql/transaction/mvcc.html#事务有哪些特性)

### Case3

#### 题目：数据库的事务隔离级别有哪些？

**答案：**

制定数据库的事务隔离级别的目的是为了防止**并行事务**导致的**数据不一致**问题。问题主要有三个：

1. **脏读**：读到其他事务未提交的数据；
2. **不可重复读**：在一个事务里，前后读取到的数据不一致；
3. **幻读**：在一个事务中，前后读取到的记录数量不一致。

上述三个问题的严重程度是脏读 > 不可重复读 > 幻读。

为了规避这三个问题，SQL标准提出了四种隔离级别，级别越高，性能效率就越低：

1. **读未提交（Read Uncommitted）**：

   - 一个事务还**没有提交**时，他做的变更就能被其他事务看到。
   - **最低**的隔离级别，存在脏读、不可重复读和幻读的问题。

2. **读已提交（Read Committed）**：

   - 一个事务**提交之后**，他做的更改才能被其他事务看到。
   - **解决了脏读**问题，但仍可能出现不可重复读和幻读。

3. **可重复读（Repeatable Read）**：

   - 一个事务执行过程中看到的数据，会一直和这个事务**启动时**看到数据保持一致，相当于拥有一份**数据拷贝**。
   - **解决了不可重复读**问题，但仍可能出现幻读。

   读已提交和可重复读都是通过**Read View**来实现的，前者在**每次从数据库读取数据时**都会重新生成一个Read View，所以虽然没有脏读问题，但是还有不可重复读和幻读；后者则是在**事务启动时**生成一个Read View，整个事务期间都使用这个Read View，但是如果使用**当前读**（select ... for update），还是会更新Read View，所以还是会有幻读的问题。

4. **序列化（Serializable）**：

   - 会对要操作的**记录上锁**，在其他事务对这条记录进行读写操作时，如果发生**读写冲突**，必须**等待当前事务执行完成**。
   - 最高的隔离级别，不存在上述三种问题，但是相当于**串行执行**，效率很低。

------

MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了）：

- 针对**快照读**（普通select语句），通过**MVCC方式解决了幻读**，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
- 针对**当前读**（select ... for update等语句），是**通过 next-key lock（记录锁+间隙锁）方式解决了幻读**，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。

详细内容参考：

[事务隔离级别是怎么实现的？ | 小林coding](https://xiaolincoding.com/mysql/transaction/mvcc.html#事务的隔离级别有哪些)

## Day17

### Case1

#### 题目：MySQL的执行引擎有哪些？

**答案：**

MySQL的存储引擎主要负责查询的执行和数据的存储，主要有`InnoDB`、`MyISAM`、`Memory` 等。

- `InnoDB`：`InnoDB`是MySQL的默认存储引擎，基于**聚簇索引**，具有ACID事务支持、**行级锁**、**外键约束**等特性。它适用于**高并发的读写**操作，支持较好的**数据完整性**和**并发控制**，但是占用空间较大。
- `MyISAM`：`MyISAM`引擎是早期的默认存储引擎，数据以**紧密格式**存储，占用较少的存储空间和内存，适用于**频繁读取少量数据**的场景。支持全文索引，但是不支持事务，也不支持行级锁和外键约束，因此在并发写入和数据完整性方面有一定的限制。
- `Memery`：`Memory`引擎将数据存储在**内存**中，访问速度快，适用于对性能要求较高的读操作，但是数据在服务器重启或崩溃时会丢失。它不支持事务、行级锁和外键约束。默认使用哈希索引，因为哈希值是无序的，所以无法用于排序，也不支持**部分索引**匹配查找，支持**等值比较**，不支持范围查找。

详细内容参考：

[MySQL有哪些存储引擎？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1zr4y1x7o7/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

[MySQL面试题 | 小林coding](https://xiaolincoding.com/interview/mysql.html#讲一讲mysql的引擎吧-你有什么了解)

### Case2

#### 题目：MySQL为什么使用B+树来作索引

**答案：**

在存储数据的时候，不仅要考虑数据结构，还要考虑**磁盘的I/O操作次数**，因为相比于内存，磁盘的访问速度是毫秒级别的，速度比内存慢上万倍。总的来说MySQL的数据结构有两个要求：

1. 尽可能少的磁盘I/O次数；
2. 高效执行**单点查询**和**范围查找**。

最基本的存储方式是**数组配合二分查找**，但是这样插入新元素的效率很低，所以第一个优化是使用**二叉排序树配合二分查找**，它解决了插入新节点的问题，但是也带来了新的问题：

1. 在一些情况下二叉树**左右会不平衡**，这时二叉树会退化为一个**链表**，查找的时间复杂度变成O(n)。
2. 进行范围查找的时候会出现**回旋查找**的问题，比如说我要找大于某个数的范围，一定会回到这个**节点的父节点**进行下一步查找。

为了解决第一个问题，出现了**平衡二叉树（AVL树）**、**红黑树**这类自平衡的树。他们最主要的约束是**每个节点的左子树和右子树的高度差不能超过1**，但是在插入的元素增多之后，**树的高度变高**，也意味着磁盘I/O次数增多，效率降低，并且仍然没有解决**回旋查找**的问题。

为了解决树的高度问题，诞生了**B树**，最大的特点是不再限制一个节点只能有2个子节点，一个M阶的B树，一个节点可以有（M - 1）个数据和M个子节点。所以树的高度大大减少，磁盘I/O次数也大大减少，但是在面对**极大数据量**的情况下呢，树的高度仍然可能过高。同时**回旋查找**依然存在。

对B树再进行升级，就得到了**B+树**。差异主要有以下两点：

- **叶子**节点才会存放**实际数据**（索引+记录），**非叶子**节点只会存放**索引**；
- 所有索引都会在叶子节点出现，叶子节点之间构成一个**有序链表**；

相比于B树，B+树在**单点查询**、**范围查找**、**插入删除**方面都有提升：

- **单点查询**：B树每个节点既存索引又存记录，所以查询速度波动会比较大。**B+树的非叶子节点只存放索引**，所以数据量相同的情况下，相比B树，B+树的非叶子节点可以存放更多的索引，因此B+树更加**「矮胖」**，查询**叶子节点**时的磁盘 I/O次数会更少。但是B树的**平均查询次数**可能会比B+树少。
- **范围查询**：B+树所有叶子节点间有一个**链表**进行连接，不像其他树需要通过树的遍历来完成范围查询，也就是说B+树最终解决了**回旋查找**的问题。对于存在大量范围检索的场景，适合使用B+树。而对于大量的单个索引查询的场景，可以考虑B树。
- **插入和删除效率**：B+树有大量的**冗余节点**，可以直接从叶子节点中删除，甚至可以不改动非叶子节点。插入也是一样，如果节点饱和，最多只会涉及树的一条路径。B树没有冗余节点，插入删除节点时可能涉及树的变形。

综上，B+树是针对数据查找和磁盘I/O进行了一系列优化后的产物。

详细内容参考：

[为什么 MySQL 采用 B+ 树作为索引？ | 小林coding](https://xiaolincoding.com/mysql/index/why_index_chose_bpuls_tree.html#mysql-中的-b-树)

[阿里总监求放过，我再也不嘚瑟了，MySQL索引数据结构为什么使用B+树，我来告诉你_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1yT4y1w7FS/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

### Case3

#### 题目：说一下索引失效的场景

**答案：**

在说明索引失效前首先需要说明MySQL的索引机制，MySQL的默认引擎是**InnoDB**，默认使用**B+树**作为存储的数据结构。**索引失效**指的是查询操作不能有效利用索引进行数据检索，从而导致性能下降，主要会出现在以下场景中：

1. **对索引使用左或者左右模糊匹配**：B+树中的所有数据是有序的，排序规则是根据数据内容的**字典序**排序，所以以**通配符`%`**开头的模糊匹配无法利用已经排序好的索引，只能全表扫描，导致索引失效。
2. **对索引使用函数**：对索引中的**某个字段使用函数**，索引会失效，比如查找某个字段长度为特定值的记录，会使用**LENGTH函数**，但是索引保存的是字段的原始值，计算之后的值自然无法使用索引。但是在MySQL8.0之后有**函数索引**可以根据函数计算后的值建立索引。
3. **对索引进行表达式计算**：原因与使用函数差不多，索引保存的是原始值。
4. **对索引隐式类型转换**：比如MySQL在遇到字符串和数字比较时，会**自动把字符串转为数字**，所以索引是字符串，SQL语句的输入是数字，索引就会失效，但是反过来索引是数字，输入是字符串则不会失效。
5. **联合索引非最左匹配**：**多个普通字段组合**在一起创建的索引叫联合索引。这时索引会按照创建时的顺序进行排序，所以需要遵循**最左匹配原则**，也就是优先确定最左边的字段。如果最左边的字段是不确定的，那么其他字段也就是**无序**的，索引就失效了。
6. **WHERE子句中的OR**：在WHERE子句中，OR连接多个条件，并且多个条件有部分**是索引列**而部分**不是索引列**时，那么索引会失效。

详细内容参考：

[索引失效有哪些？ | 小林coding](https://xiaolincoding.com/mysql/index/index_lose.html#索引存储结构长什么样)

[【吊打面试官】MySQL索引失效的底层原理，终于有人讲清楚了_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Sp4y1e7W6/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

## Day18

### Case1

#### 题目：什么是慢查询？原因是什么？可以怎么优化？

**答案：**

顾名思义，慢查询就是执行时间**超过指定的时间**的查询语句。如果SQL运行较慢，我们会认为执行过程中出现了慢查询，这时会打开**慢查询日志**来记录慢查询，相关参数有以下几个：

- **slow_query_log**表示是否打开慢查询日志，默认是关闭的，因为会影响MySQL性能。
- **slow_query_log_file**记录了慢查询日志存储路径。
- **long_query_time**是**慢查询阈值**，查询时间比阈值长会被认为是慢查询，记录在日志中。

下面说明慢查询**如何优化**以及出现的**原因**：

1. 首先是打开慢查询日志来记录SQL语句，优先选择**高并发执行的SQL语句**进行优化，因为高并发的SQL发生问题带来的后果更严重。
2. 第二步是了解被定位的SQL语句的**性能瓶颈**，因为性能瓶颈导致的慢查询通常有三个原因：
   - **磁盘I/O次数过多**，数据的访问消耗了太多的时间，优化思路是查看是否正确使用了**索引**。
   - **CPU占用较高**，数据运算消耗太多时间，优化思路是判断数据的**运算分组和排序**是否有问题。
   - **网络带宽太小**，需要优化网络。
3. 了解性能瓶颈之后，从**explain执行计划**入手，查看该条SQL语句如何**使用索引**、连接了**多少表格**以及如何**处理select语句**，下面是针对不同问题的优化：
   - **数据库连接次数过多**：要用**小的结果集驱动大的结果集**，类似于嵌套循环，如果小循环在外层，那么对于数据库来说，比大循环在外层需**要连接数据库的次数少**，可以节省资源减少消耗。
   - **缺少索引**：尽可能使用索引进行**查找**，**排序**操作order by后的字段最好也使用索引，索引本来就是有序的，查询和排序速度会很快，否则前者要**全表扫描**，后者需要**在内存中进行排序**。
     除了SQL需要合理利用索引，表格也需要合理设计索引：
     - **查询频繁**的字段要创建索引；
     - **唯一性太差**的字段不适合单独创建索引；
     - **更新频繁**的字段不适合创建索引；
     - 创建**联合索引**时，过滤性好的字段要靠前。
   - **使用`select *`**：select *需要数据库获取每个字段的值，可能导致**覆盖索引**无法使用，需要**回表**，所以最好只查询**必要的字段值**。
   - **where后条件过多**：最好的处理方式是用**最短路径**到达数据，过多条件会降低性能。
   - **复杂的join和子查询**：JOIN占用的资源过多，不仅会导致该条SQL**执行时间长**，也会导致其他进程的**等待时间长**。每条SQL的JOIN最好不要超过三张表，如果需要用到多张表，可以拆分为多个小SQL，将获取的结果进行封装。

详细内容参考：

[面试美团，被问：如何做慢查询优化？答完直接给了30k【马士兵】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Vc411P7q9/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

### Case2

#### 题目：undo log、redo log、bin log有什么用？

**答案：**

**undo log**：

- **基本概念**：undo log是一种用于**撤销回退**的日志，在数据库事务开始之前，MySQL会先**记录更新前的数据**到undo log日志文件里，当事务回滚或者数据库崩溃时，可以利用undo log来进行回退。
- **产生和销毁**：undo log在事务开始前产生，会先被写入**缓冲池**中的Undo页面，缓冲池是InnoDB为了提高数据库读写性能而设计的。事务提交之后，不会立刻删除undo log，InnoDB会将事务对应的undo log放入删除列表，通过后台线程purge thread进行回收。

**undo log的作用**：

- **提供回滚操作**：undo log实现了事务的**原子性**，在事务执行过程中，如果因为某些原因导致事务执行失败了，可以借助undo log进行回滚。
- **提供多版本并发控制（MVCC）**：InnoDB中使用undo log来实现MVCC，当一个进程读取的某一行被其他事务锁定时，它可以**从undo log中分析**出该行记录之前的版本，从而读到当前事务之前的快照。

**redo log**：

- **基本概念**：前面提到InnoDB为了提高读写效率设计了缓冲池，但是缓冲池是**基于内存**的，**断电重启**后没有落盘的脏页**数据就会丢失**。为了避免事故，InnoDB在记录更新时，**先更新缓冲池**，然后将修改以redo log的形式记录，然后再**系统空闲**或者根据**设定的策略**将日志内容**更新到磁盘**，也就是**WAL（Write-Ahead Logging）技术**。
- redo log由两部分组成，一个是内存中的**日志缓冲：`redo log buffer`**，另一个是磁盘上的**日志文件：`redo log file`**。

**redo log的作用**：

- 实现了**事务的持久性**，事务提交时，只要将redo log持久化到磁盘，不需要等到缓存的脏页数据持久化。这时候如果**系统崩溃**，虽然脏页没有持久化，但是**redo log已经持久化**，所以在重启后可以根据redo log将数据恢复到最新的状态。
- 将磁盘的数据写入从**随机写变为顺序写**，磁盘写入数据需要先找到写入位置，如果每条数据更新都是**即时**的，那么随机写的开销会很大，而redo log可以将**多次更新组合为顺序写**，提高了读写性能。

**bin log**：

- bin log用于记录用户**更新数据库**的SQL语句信息，他在MySQL的Server层实现，是所有引擎共用的。
- bin log是**逻辑日志**，也就是说记录的是SQL语句中的**原始逻辑**，相对而言还有**物理日志**，会存储数据库中一条记录**修改前后的值**。前面提到的undo log也是逻辑日志，redo log则是物理日志。
- bin log不限制大小，追加写入，不会覆盖之前的日志，默认情况下是二进制格式，需要用**mysqlbinlog工具**解析查看。

**bin log的作用**：

- **主从复制**：主库开启bin log功能后，将更新**写入bin log**，从库**同步bin log**，然后**回放bin log**，将从库的数据更新到主库的版本。
- **数据恢复**：通过**mysqlbinlog工具**来恢复数据。

详细内容参考：

[MySQL 日志：undo log、redo log、binlog 有什么用？ | 小林coding](https://xiaolincoding.com/mysql/log/how_update.html#为什么需要-undo-log)

[面试阿里，被问：undo log、redo log、 bin log的作用是什么？答完直接给了30k_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV18u4y1Z7LA/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

redo log**何时刷盘**参考第一个连接。

## Day19

### Case1

#### 题目：MySQL和Redis的区别是什么

**答案：**

他们的主要区别在于以下几点：

1. **数据库类型**：在数据库类型上，Redis是**非关系型数据库**，存储数据基于键值对，支持多种数据结构，比如**String**（字符串），**Hash**（哈希），**List**（列表），**Set**（集合）、**Zset**（有序集合）；MySQL是**关系型数据库**，使用**表格**来组织数据，支持的数据类型则是**日期/时间**、**字符串**、**浮点数**、**整数**等。
2. **操作方式**：MySQL和Oracle等数据库类似，使用**SQL语句**操作数据库，相对而言学习成本可能更低，而Redis不使用SQL，有自己的一套**命令集**。
3. **数据存储位置**：**MySQL**主要将数据存储在**磁盘**上，而**Redis**主要将数据存放在**内存**中。MySQL更偏向于**存储数据**，而Redis偏向于**快速取出数据**。
   Redis也可以实现**持久化**，Redis的读写操作在内存中，为了保证数据不丢失，它实现了三种持久化的方式，分别是：
   - **AOF日志**：每执行一条写操作，就把该命令以追加的方式写入到一个文件里；
   - **RDB快照**：将某一时刻的内存数据，以二进制的形式写入磁盘；
   - **混合持久化方式**：Redis4.0新增的方式，集成了AOF和RDB的优点。
4. **性能瓶颈**：MySQL的数据存储在磁盘，并且运行时是**多线程**，所以频繁访问时会在**磁盘I/O**出现瓶颈；Redis的数据在内存中，运行时虽然会启动**后台线程**，但是接收客户端请求、解析请求、数据读写、返回数据等都是由一个线程完成的，所以常说Redis是**单线程**，所以Redis的性能瓶颈在于机器的**内存和带宽**。

综上，Redis具有高性能的特点，并且使用**I/O多路复用**实现了高并发，而MySQL适用于处理复杂查询和大规模数据集场景，实际应用通常会结合两者，将Redis作为MySQL的**缓存**。

详细内容参考：

[Redis 常见面试题 | 小林coding](https://xiaolincoding.com/redis/base/redis_interview.html#认识-redis)

Redis持久化：[Redis 常见面试题 | 小林coding](https://xiaolincoding.com/redis/base/redis_interview.html#redis-持久化)

### Case2

#### 题目：Redis有什么优缺点？为什么用Redis查询会比较快

**答案：**

1. **Redis的优缺点**：

   **优点**：

   - Redis是一个**基于内存**的数据库，读写速度快，通常被用作**缓存**、消息队列、分布式锁和键值存储数据库。
   - 支持多种数据结构，如**String**（字符串），**Hash**（哈希），**List**（列表），**Set**（集合）、**Zset**（有序集合）等。
   - 支持**事务**，操作具有原子性。
   - 可以按key设置**过期时间**，到期之后自动删除。
   - 提供了**分布式**、**主从复制**等特性。

   **缺点**：

   - 受限于**物理内存**的大小，不适合存储大量数据，相比磁盘存储成本更高。

2. **Redis查询为什么快**：

   - **基于内存**：Redis有关数据的操作都是在**内存**中进行的，相比于磁盘文件操作，速度本来就要快很多，同时避免了**磁盘I/O**的成本。
   - **单线程避免上下文切换**：Redis运行时虽然会启动**后台线程**，但是接收客户端请求、解析请求、数据读写、返回数据等都是由一个线程完成的，所以常说Redis是**单线程**，所以Redis避免了**上下文切换的成本**，减少了消耗。
   - **渐进式ReHash**：Redis使用了一个**全局哈希表**来保存所有键值对，底层使用**数组**实现的，那么随着Redis运行，哈希表会多次进行扩容，扩容过程中需要进行**重哈希**，在数据量大的情况下，重哈希会导致长时间的阻塞。
     Redis采用了渐进式重哈希解决了这个问题，默认使用**两张全局哈希表**，一开始使用表1，表2没有被分配空间，执行重哈希的时候，先给表2分配空间，然后将表1中的数据拷贝到表2中，再释放表1的空间。拷贝操作会被**分摊到多次处理请求的过程中**，避免了阻塞的问题。
   - **缓存时间戳**：Redis中经常要使用**时间相关**的数据，每一次获取**系统时间戳**都是一次**系统调用**，都有**用户态和内核态切换**的成本。Redis作为单线程获取时间戳成本太大，所以Redis的时间戳由一个**定时任务每毫秒**更新，存储到**缓存**中，获取时间戳直接访问缓存。

详细内容参考：

[什么是 Redis，有什么优缺点？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV17P4y1F7ef/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

[Redis刷题01：Redis为什么快？——马士兵Java刷题班_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV14m4y1k7C2/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

## Day20

### Case1

#### 题目：Redis的数据类型有哪些？

**答案：**

Redis 常见数据类型有以下五种：**String（字符串），Hash（哈希），List（列表），Set（集合）及 Zset(sorted set：有序集合)**。

1. 字符串`STRING`：可以存储**字符串、整数或浮点数**，可以对字符串进行部分或全部读写，对整数或浮点数进行自增自减。常用于缓存对象、常规计数、分布式锁、共享session信息等。
2. 哈希表`HASH`：存储键值对的无序哈希表，可以添加、获取、删除单个元素。
3. 列表`LIST`：用链表存储字符串，可以在**两端push和pop**，也可以**根据值**查找或者删除元素。常用于消息队列。
4. 集合`SET`：用于**无序**地存储**唯一**字符串，可以计算**交集、并集、差集**等。
5. 有序集合`ZSET`：用于存储**键值对**，key是字符串，value是**浮点数分数**，按照分数的大小排序。常用于需要排序的场景。

随着Redis版本更新，又增加了以下几种数据类型，

- `BitMap`: 存储**位**的数据结构，可以用于处理一些**位运算**操作，适合**二值状态统计**的场景，比如签到等。
- `HyperLogLog`：用于**基数估算**的数据结构，用于统计元素的**唯一数量**。
- `GEO`： 存储**地理位置信息**的数据结构。
- `Stream`：专门为**消息队列**设计的数据类型。与List实现的消息对象相比，可以自动生成**全局唯一消息ID**，支持以**消费组形式**消费数据。

详细内容参考：

[Redis 常见面试题 | 小林coding](https://xiaolincoding.com/redis/base/redis_interview.html#redis-数据类型以及使用场景分别是什么)

### Case2

#### 题目：Redis是单线程的还是多线程的，为什么？

**答案：**

Redis的单线程指的是「接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端」这个过程是由**一个线程（主线程）**来完成的，所以常说Redis是单线程，但是这并不代表它只运行一个线程。

Redis在运行的时候会启动**多个后台线程**：

- 在2.6版本时，会启动两个后台线程，分别用于**关闭文件**和**AOF刷盘**；
- 4.0版本之后，新增了一个后台线程用于**异步释放Redis内存**。

虽然处理请求的线程只有一个，但是Redis的吞吐量可以达到**10W/每秒**，主要原因是：

1. **基于内存**：Redis大部分操作都在内存中完成，结合高效的数据结构，**CPU不是Redis的瓶颈**，所以可以使用单线程。
2. **简化模型**：单线程模型简化了并发控制，避免了复杂的**多线程同步**问题，也就没有**加锁**的开销，也保证了操作的**原子性**，简化了**事务的实现**。
3. **多路复用**：Redis还采用**I/O多路复用**处理Socket请求。

之后随着网络硬件性能的提升，Redis的瓶颈有时会出现在网络I/O的处理上，所以`Redis 6.0` 引入了**I/O的多线程**，用于缓解网络I/O的压力。

详细内容参考：

[Redis 常见面试题 | 小林coding](https://xiaolincoding.com/redis/base/redis_interview.html#redis-是单线程吗)

### Case3

#### 题目：说一说Redis持久化机制有哪些

**答案：**

Redis的读写操作都是在内存中，重启后数据会丢失，所以Redis实现了**数据持久化**的机制把数据写入磁盘，重启后能够从磁盘中恢复原有的数据。

主要有三种持久化机制：

1. **AOF日志**：Redis在执行完一条写操作命令后，会把该命令以追加的方式写入一个文件。写入文件的时间在执行完命令后有两个好处：

   - **避免额外的检查开销**，如果先写日志，那么当前命令如果语法有问题，Redis在使用日志时会出错。
   - **不会阻塞当前写操作命令的执行**。

   但是也会存在一定风险：

   - **数据可能丢失**，如果在写日志之前服务器宕机了，就可能会丢失这个数据。
   - **可能阻塞其他操作**，AOF日志也是在主线程中执行，虽然不会阻塞当前的写命令，但是之后的操作可能被阻塞。

   AOF**写回的策略**有三种：

   - **Always**：每次执行完写操作就将AOF日志写回硬盘；
   - **Everysec**：执行写操作之后，先将AOF日志写入缓冲区，每隔一秒将缓冲区的内容写入硬盘。
   - **No**：写回的时间不由Redis控制，日志先写入缓冲区，由操作系统决定何时写回。

   当AOF日志**过大**的时候，Redis会启动**重写机制**，会读取当前所有的键值对，每个键值对对应一条命令写入新日志，这样避免了**键值对反复修改**的命令占用空间。在重写期间执行的写命令不仅会写入AOF缓冲区，也会写入AOF**重写缓冲区**。这个过程是由**后台子进程**完成的，这样**不需要阻塞主进程**，而且设置子进程**仅读取内存**也不用考虑进程间的**数据安全问题**。

2. **RDB快照**：AOF日志记录的是操作命令，恢复数据需要执行整个日志的命令，比较耗时。所以有了RDB快照，快照会将执行时刻内存中的**所有数据**以**二进制**的方式写入硬盘。快照有两种执行方式：

   - **save**会在主线程生成RDB文件，也就是说会**阻塞主线程**；
   - **bgsave**会创建一个**子进程**生成RDB文件，不用阻塞主线程。在bgsave的过程中，因为子进程和父进程共享了同一片内存数据，主进程可以依赖**写时复制技术**继续处理命令。

3. **混合持久化**：在Redis4.0新增，在重写**AOF日志重写时**工作，流程是**创建子进程**将当前的共享数据以**RDB方式**写入日志，同时主线程**正在执行**的命令会被写入**重写缓冲区**，最后缓冲区内的命令会按照**AOF的方式追加**写入日志。这样做的**优点**在于：

   - 日志前半段是RDB格式，Redis可以**更快启动**
   - 结合了AOF的优点，减少了**丢失大量数据**的风险。

   **缺点**在于：

   - AOF文件可读性很差
   - Redis4.0往后的版本才能使用，兼容性差。

详细内容参考：

[Redis 常见面试题 | 小林coding](https://xiaolincoding.com/redis/base/redis_interview.html#redis-持久化)













