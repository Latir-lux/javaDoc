# 八股训练营

## Day31

### Case1

#### 题目：Java创建线程有哪几种方式？

**答案：**

在`Java`中，创建线程主要有以下几种方式：

1. **继承Thread类**：继承`Thread`类，并重写其`run`方法来定义线程执行的任务。缺点在于`Java`只支持单继承，所以继承`Thread`类成本很高。
2. **实现Runnable接口**：实现了`Runnable`接口，并重写其`run`方法。然后创建该类的**实例**作为参数传递给`Thread`对象。比继承的方式更灵活，但是这两种方式都无法在线程执行完之后返回值。
3. **使用Callable接口和FutureTask**：实现了`Callable`接口，并重写其`call`方法，该方法可以返回结果并抛出异常。将实现了`Callable`接口的类的实例，作为参数传递给`FutureTask`对象，再将`FutureTask`对象传递给`Thread`类，就可以使用**`start()`**方法启动线程。
4. **使用线程池**：前三种方法实际上都通过`new`一个`Thread`对象来创建线程，通过`Executors`类创建线程池，过程是向`ExecutorService`类对象传入一个实现了`Runnable`接口的对象，调用对象的`execute`方法。
5. **使用CompletableFuture类**：这是JDK1.8引入的类，可以用来执行异步任务。

虽然看上去创建线程的方法有很多，但是严格来说只有一种方法，因为这些方式最终都实现了`Runnable`接口，并且都依赖于`new Thread().start()`来创建线程。

详细内容参考：

[腾讯一面：请问java如何创建线程？创建线程的方式有几种？搞懵了。。_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Ru4y1n7Lw/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

[Java并发常见面试题总结（上） | JavaGuide](https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html#如何创建线程)

### Case2

#### 题目：线程start和run的区别

**答案：**

在Java多线程中，`run`方法和`start`方法的区别在于：

1. `start()`方法Java线程的内置方法，包含了创建新线程的代码逻辑，能够确保代码在**新线程**的上下文中运行。调用后会为线程分配系统资源，让线程处于就绪状态，调度器选择该线程时，会执行`run()`方法中的代码。一个线程在他的生命周期中**只能调用一次**`start()`方法，如果多次调用会抛出异常，表示该线程已经启动过了，不能再次启动。
2. 而`run()`方法是程序员定义的，是线程的执行体，不能创建新的线程，只会在**当前线程的**上下文中执行。如果直接调用`run()`方法，那只是一个**普通的方法调用**，仍然只有一个主线程，并且只能顺序执行，`run()`方法执行完成后才会执行后面的代码。

因此，`run()`方法并不会创建一个新的线程，如果需要实现多线程执行，需要调用`start()`方法来启动新线程。

详细内容参考：

[【Java高级】为什么启动线程不直接调用run()，而要调用start()，如果调用两次start()方法会有什么后果？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1s8411W7hV/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

## Day32

### Case1

#### 题目：你知道Java中有哪些锁吗

**答案：**

Java当中的锁主要是为了实现线程操作的原子性、有序性和可见性，来保证线程安全。主要有以下几类锁：

1. 从功能层面来说，只有<u>**共享锁**和**排他锁**</u>两类锁：共享锁可以被多个线程持有，排他锁一次只能被一个线程持有。Java中排他锁的具体实现就是`ReentrantLock`和`Synchronized`，`ReadWriteLock`则是**读写锁**的具体实现，当中的读锁是共享锁，写锁是排他锁。

2. 从看待并发同步的角度来说，可以分为<u>**乐观锁**和**悲观锁**</u>，他们并不是具体的锁的类型。
   - 悲观锁认为对于同一个数据的并发操作中，写操作比较多，很容易出现数据不一致的问题，所以在并发操作时，一定要**先获取锁**，才可以执行后面的操作。
   - 乐观锁则认为对同一个数据的并发操作中，写操作比较少，不容易出现数据不一致的问题，所以在并发操作时不需要先获取锁。在执行时选择**先修改**数据，再验证这段时间有没有**其他线程在修改**数据，如果没有，操作完成，如果有就放弃本次操作。乐观锁全程没有加锁，所以也可以叫无锁编程。

   从二者的描述可以看出，悲观锁适合写操作非常多的场景，防止数据冲突，在Java多数利用锁的场景都是悲观锁；乐观锁适合读操作非常多的场景，可以带来大量的性能提升，Java常见的乐观锁是**CAS算法**，比如原子类（`java.utl.concurrent.atomic`），通过CAS自旋实现原子操作的更新。

3. 从锁的状态来说，可以把锁分为**偏向锁、轻量级锁、重量级锁**，这三个概念在Java中是针对`Synchronized`来说的。
   在说明这三个锁之前，需要先明确加锁的本质是竞争同步状态或者静态变量，对`Synchronized`来说就是在**操作系统层面**竞争**Mutex机制**，期间会涉及内核指令的调用，带有内核态用户态切换的开销，为了减少这部分开销，出现了上述的三种锁：

   - **偏向锁**指的是一个线程获取锁时如果不存在竞争，那么锁会偏向这个线程，当线程下一次在进入时可以自动获取锁。
   - **轻量级锁**指的是当一个线程持有偏向锁时，这个锁被另一个线程访问了，会升级为轻量级锁，这时其他线程会通过自旋的方式尝试获取锁，不会阻塞，也就没有内核态用户态的切换，提高了性能。
   - **重量级锁**则是我们常见的锁，一个线程没有获得锁时，自旋到一定次数会进入阻塞，这时锁也会升级为重量级锁。

4. **可重入锁**：一个线程在获取一个锁之后，线程内部再次获取这个锁可以直接获得，如果时不可重入锁，这样会发生死锁。Java中的`ReentrantLock`和`Synchronized`都是可重入锁。

5. **公平锁和非公平锁**：公平锁指多个线程按照**申请锁的顺序来获取锁**，非公平锁指线程获取锁的顺序并不是按照申请锁的顺序，会存在**线程之间的优先级**。Java中的`ReentrantLock`和`Synchronized`都是非公平锁。非公平锁虽然可能导致**优先级反转**或者**饥饿**现象，但是等待的时间更短，性能更好。

6. **分布式锁**：用于结局分布式架构下的粒度问题，对比`Synchronized`用于线程层面，分布式锁用于进程层面。

7. **分段锁**：分段锁不是具体的锁，是一种锁的设计，JDK1.7中`ConcurrentHashMap`就是通过分段锁实现并发操作。

详细内容参考：

[10分钟彻底搞懂Java中的各种锁，接近天花板级别的回答！【Java知识分享】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Ju4y1P7Mf/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

### Case2

#### 题目：说一说你对synchronized的理解

**答案：**

`synchronized`是Java中的一个关键字，用于实现同步和线程安全。当一个**方法或代码块**被`synchronized`修饰时，它将成为一个临界区，同一时刻只能由一个线程访问，确保多个线程在访问共享资源时不会产生冲突。

- `synchronized`的底层是由`monitor`实现的，`monitor`是一个jvm级别的对象，所以`synchronized`可以在源文件被编译成为字节码时，在临界区前加上`MONITORENTER`表示进入临界区，临界区后加上`MONITOREXIT`表示离开临界区。
- `monitor`包含**`owner`、`entrylist`、`waitlsit`**三个属性，`owner`存储当前获得锁的线程；`entrylist`关联没有抢到锁，处于阻塞状态的线程；`waitlsit`关联调用了wait方法，处于等待状态的线程。
- `synchronized`实现的机制依赖于软件层面上的`JVM`，因此性能会随着JDK版本升级而提高。在`JDK1.6`之前，使用的都是**重量级锁**，也就是悲观锁。到了`JDK1.6`，引入了适应自旋、锁消除、锁粗化、偏向锁、轻量级锁还有锁升级等。锁升级具体流程如下：
  - 在一个临界区没有线程进入时，是无锁状态；
  - **偏向锁**是当一个线程要进入这个临界区，获取锁时如果不存在竞争，那么锁会偏向这个线程，该线程下一次在进入时可以自动获取锁。
  - **轻量级锁**指的是当一个线程持有偏向锁时，偏向锁被另一个线程访问了，会升级为轻量级锁，这时其他线程会通过自旋的方式尝试获取锁，也就是`CAS`乐观锁。
  - 轻量级锁自旋了十次之后会升级为**重量级锁**，这时线程就会在未获得锁时阻塞。
- 在后续的升级中，因为**性能收益**并不明显，而且**代码维护成本**过高，`JDK15`默认关闭了偏向锁，而`JDK18`彻底废弃了偏向锁。
- 需要注意的是，当线程通过`synchronized`等待锁时是不能被`Thread.interrupt()`中断的，因此程序设计时要确保逻辑合理，否则可能会造成死锁。

- `Java`实现的锁机制有很多种，有些锁机制性能也比`synchronized`好，但是`synchronized`实现方便，依赖`JVM`来完成工作，可靠性高，所以只有在确定锁机制是当前多线程程序的**性能瓶颈**时，才考虑使用其他锁机制，比如`ReentrantLock`等。

详细内容参考：

[【大厂面试】聊聊你对Synchronized的理解_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1W3411K7PD/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

[并发编程篇-09-线程安全-synchronized关键字的底层原理-基础回答_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1yT411H7YK/?p=94&share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

[Java并发常见面试题总结（中） | JavaGuide](https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#synchronized-关键字)





