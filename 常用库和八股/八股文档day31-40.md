# 八股训练营

## Day31

### Case1

#### 题目：Java创建线程有哪几种方式？

**答案：**

在`Java`中，创建线程主要有以下几种方式：

1. **继承Thread类**：继承`Thread`类，并重写其`run`方法来定义线程执行的任务。缺点在于`Java`只支持单继承，所以继承`Thread`类成本很高。
2. **实现Runnable接口**：实现了`Runnable`接口，并重写其`run`方法。然后创建该类的**实例**作为参数传递给`Thread`对象。比继承的方式更灵活，但是这两种方式都无法在线程执行完之后返回值。
3. **使用Callable接口和FutureTask**：实现了`Callable`接口，并重写其`call`方法，该方法可以返回结果并抛出异常。将实现了`Callable`接口的类的实例，作为参数传递给`FutureTask`对象，再将`FutureTask`对象传递给`Thread`类，就可以使用**`start()`**方法启动线程。
4. **使用线程池**：前三种方法实际上都通过`new`一个`Thread`对象来创建线程，通过`Executors`类创建线程池，过程是向`ExecutorService`类对象传入一个实现了`Runnable`接口的对象，调用对象的`execute`方法。
5. **使用CompletableFuture类**：这是JDK1.8引入的类，可以用来执行异步任务。

虽然看上去创建线程的方法有很多，但是严格来说只有一种方法，因为这些方式最终都实现了`Runnable`接口，并且都依赖于`new Thread().start()`来创建线程。

详细内容参考：

[腾讯一面：请问java如何创建线程？创建线程的方式有几种？搞懵了。。_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Ru4y1n7Lw/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

[Java并发常见面试题总结（上） | JavaGuide](https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html#如何创建线程)

### Case2

#### 题目：线程start和run的区别

**答案：**

在Java多线程中，`run`方法和`start`方法的区别在于：

1. `start()`方法Java线程的内置方法，包含了创建新线程的代码逻辑，能够确保代码在**新线程**的上下文中运行。调用后会为线程分配系统资源，让线程处于就绪状态，调度器选择该线程时，会执行`run()`方法中的代码。一个线程在他的生命周期中**只能调用一次**`start()`方法，如果多次调用会抛出异常，表示该线程已经启动过了，不能再次启动。
2. 而`run()`方法是程序员定义的，是线程的执行体，不能创建新的线程，只会在**当前线程的**上下文中执行。如果直接调用`run()`方法，那只是一个**普通的方法调用**，仍然只有一个主线程，并且只能顺序执行，`run()`方法执行完成后才会执行后面的代码。

因此，`run()`方法并不会创建一个新的线程，如果需要实现多线程执行，需要调用`start()`方法来启动新线程。

详细内容参考：

[【Java高级】为什么启动线程不直接调用run()，而要调用start()，如果调用两次start()方法会有什么后果？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1s8411W7hV/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

## Day32

### Case1

#### 题目：你知道Java中有哪些锁吗

**答案：**

Java当中的锁主要是为了实现线程操作的原子性、有序性和可见性，来保证线程安全。主要有以下几类锁：

1. 从功能层面来说，只有<u>**共享锁**和**排他锁**</u>两类锁：共享锁可以被多个线程持有，排他锁一次只能被一个线程持有。Java中排他锁的具体实现就是`ReentrantLock`和`Synchronized`，`ReadWriteLock`则是**读写锁**的具体实现，当中的读锁是共享锁，写锁是排他锁。

2. 从看待并发同步的角度来说，可以分为<u>**乐观锁**和**悲观锁**</u>，他们并不是具体的锁的类型。
   - 悲观锁认为对于同一个数据的并发操作中，写操作比较多，很容易出现数据不一致的问题，所以在并发操作时，一定要**先获取锁**，才可以执行后面的操作。
   - 乐观锁则认为对同一个数据的并发操作中，写操作比较少，不容易出现数据不一致的问题，所以在并发操作时不需要先获取锁。在执行时选择**先修改**数据，再验证这段时间有没有**其他线程在修改**数据，如果没有，操作完成，如果有就放弃本次操作。乐观锁全程没有加锁，所以也可以叫无锁编程。

   从二者的描述可以看出，悲观锁适合写操作非常多的场景，防止数据冲突，在Java多数利用锁的场景都是悲观锁；乐观锁适合读操作非常多的场景，可以带来大量的性能提升，Java常见的乐观锁是**CAS算法**，比如原子类（`java.utl.concurrent.atomic`），通过CAS自旋实现原子操作的更新。

3. 从锁的状态来说，可以把锁分为**偏向锁、轻量级锁、重量级锁**，这三个概念在Java中是针对`Synchronized`来说的。
   在说明这三个锁之前，需要先明确加锁的本质是竞争同步状态或者静态变量，对`Synchronized`来说就是在**操作系统层面**竞争**Mutex机制**，期间会涉及内核指令的调用，带有内核态用户态切换的开销，为了减少这部分开销，出现了上述的三种锁：

   - **偏向锁**指的是一个线程获取锁时如果不存在竞争，那么锁会偏向这个线程，当线程下一次在进入时可以自动获取锁。
   - **轻量级锁**指的是当一个线程持有偏向锁时，另一个线程也尝试获取偏向锁，会升级为轻量级锁，这时其他线程会通过自旋的方式尝试获取锁，不会阻塞，也就没有内核态用户态的切换，提高了性能。
   - **重量级锁**则是我们常见的锁，一个线程没有获得锁时，自旋到一定次数会进入阻塞，这时锁也会升级为重量级锁。

4. **可重入锁**：一个线程在获取一个锁之后，线程内部再次获取这个锁可以直接获得，如果时不可重入锁，这样会发生死锁。Java中的`ReentrantLock`和`Synchronized`都是可重入锁。

5. **公平锁和非公平锁**：公平锁指多个线程按照**申请锁的顺序来获取锁**，非公平锁指线程获取锁的顺序并不是按照申请锁的顺序，会存在**线程之间的优先级**。Java中的`ReentrantLock`和`Synchronized`都是非公平锁。非公平锁虽然可能导致**优先级反转**或者**饥饿**现象，但是等待的时间更短，性能更好。

6. **分布式锁**：用于解决分布式架构下的粒度问题，对比`Synchronized`用于线程层面，分布式锁用于进程层面。

7. **分段锁**：分段锁不是具体的锁，是一种锁的设计，JDK1.7中`ConcurrentHashMap`就是通过分段锁实现并发操作的。

详细内容参考：

[10分钟彻底搞懂Java中的各种锁，接近天花板级别的回答！【Java知识分享】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Ju4y1P7Mf/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

### Case2

#### 题目：说一说你对synchronized的理解

**答案：**

`synchronized`是Java中的一个关键字，用于实现同步和线程安全。当一个**方法或代码块**被`synchronized`修饰时，它将成为一个临界区，同一时刻只能由一个线程访问，确保多个线程在访问共享资源时不会产生冲突。

- `synchronized`的底层是由`monitor`实现的，`monitor`是一个jvm级别的对象，所以`synchronized`可以在源文件被编译成为字节码时，在临界区前加上`MONITORENTER`表示进入临界区，临界区后加上`MONITOREXIT`表示离开临界区。
- `monitor`包含**`owner`、`entrylist`、`waitlsit`**三个属性，`owner`存储当前获得锁的线程；`entrylist`关联没有抢到锁，处于阻塞状态的线程；`waitlsit`关联调用了wait方法，处于等待状态的线程。
- `synchronized`实现的机制依赖于软件层面上的`JVM`，因此性能会随着JDK版本升级而提高。在`JDK1.6`之前，使用的都是**重量级锁**，也就是悲观锁。到了`JDK1.6`，引入了适应自旋、锁消除、锁粗化、偏向锁、轻量级锁还有锁升级等。锁升级具体流程如下：
  - 在一个临界区没有线程进入时，是无锁状态；
  - **偏向锁**是当一个线程要进入这个临界区，获取锁时如果不存在竞争，那么锁会偏向这个线程，该线程下一次在进入时可以自动获取锁。
  - **轻量级锁**指的是当一个线程持有偏向锁时，另一个线程尝试获取偏向锁，会升级为轻量级锁，这时其他线程会通过自旋的方式尝试获取锁，也就是`CAS`乐观锁。
  - 轻量级锁自旋了十次之后会升级为**重量级锁**，这时线程就会在未获得锁时阻塞。
- 在后续的升级中，因为**性能收益**并不明显，而且**代码维护成本**过高，`JDK15`默认关闭了偏向锁，而`JDK18`彻底废弃了偏向锁。
- 需要注意的是，当线程通过`synchronized`等待锁时是不能被`Thread.interrupt()`中断的，因此程序设计时要确保逻辑合理，否则可能会造成死锁。

- `Java`实现的锁机制有很多种，有些锁机制性能也比`synchronized`好，但是`synchronized`实现方便，依赖`JVM`来完成工作，可靠性高，所以只有在确定锁机制是当前多线程程序的**性能瓶颈**时，才考虑使用其他锁机制，比如`ReentrantLock`等。

详细内容参考：

[【大厂面试】聊聊你对Synchronized的理解_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1W3411K7PD/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

[并发编程篇-09-线程安全-synchronized关键字的底层原理-基础回答_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1yT411H7YK/?p=94&share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

[Java并发常见面试题总结（中） | JavaGuide](https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#synchronized-关键字)

## Day33

### Case1

#### 题目：synchronized和lock的区别是什么

**答案：**

`synchronized`和`lock`的区别主要有以下几点：

1. 从**功能**角度看，`synchronized`和`Lock`都是Java中用于实现线程同步的手段。
2. 从**特性**角度看
   - `synchronized`是Java的关键字，基于JVM的内置锁实现，可以用于修饰**方法**或**代码块**，不同的修饰位置**锁粒度**不同，而且可以通过`synchronized`加锁对象的生命周期来可控制作用范围，比如锁对象是**静态对象**或者**类对象**，那就是**全局锁**；如果是**普通对象**，作用域则取决于**对象的生命周期**。
   - 而`Lock`是java`J.U.C(java.util.concurrent)`包中的接口，有很多的实现类，比如说`ReentrantLock`。`Lock`是一种显式锁机制，需要手动获取和释放锁，也就是通过`lock()`方法和`unlock()`方法来控制锁的粒度。在两个方法之间的代码可以保证线程安全，而`Lock`实例的**生命周期**决定了锁的作用域。
3. **灵活性**区别：
   - ` lock`灵活性更高，可以自主决定加锁和释放锁的时机。还提供了**非阻塞竞争锁**的方法`trylock()`，可以返回`true/false`来表示锁是否被其他线程持有，如果返回false，可以选择**等待**或者**中断等待**。提供了超时机制，在一定时间内尝试获得锁，超时就放弃。
   - `synchronized`是关键字，无法实现非阻塞竞争锁，灵活性相对较低。`synchronized`锁的释放是被动的，只有代码或者方法**执行完成**或者**遇到异常**才会释放。而且`synchronized`方法一旦开始执行，即使线程被阻塞，也不能中断。没有超时机制，获取不到锁就会一直等待。
4. **公平锁/非公平锁**：`Lock`提供了公平锁和非公平锁的机制，`synchronized`只提供了非公平锁的实现。
5. **性能方面**：两者性能相差不大。
   - `synchronized`提供了**偏向锁、轻量级锁、重量级锁、锁升级**等机制来优化。还可以与`wait()`和`notify()/notifyAll()`方法一起使用，用于线程的等待和通知。
   - `Lock`使用**自旋锁**的机制进行优化。可以与`Condition`接口结合，实现更细粒度的线程等待和通知机制。
6. **使用场景**：`synchronized`适合锁的粒度较小、竞争不激烈、实现简单的场景。而`Lock`更加灵活，适用于需要更复杂的同步控制的场景。

详细内容参考：

[【Java面试】面试被问lock和synchronized的区别，如何回答轻松搞定面试官！_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1XS4y1S7W1/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

### Case2

#### 题目：synchronized和ReentrantLock的区别是什么

**答案：**

`synchronized`和`ReentrantLock`主要有以下几点区别：

在**使用层面**上：

1. `synchronized`和`ReentrantLock`都是Java中用于实现线程同步的手段，都是**可重入锁**。其中
   - `synchronized`是Java的关键字，基于**JVM的内置锁**实现，java中对于`synchronized`的优化都是JVM层面的，不会直接暴露给程序员。他可以用于修饰方法或代码块，是一个**对象锁**或者说**类锁**，使用时需要用到**堆内存**中存储的一个**对象**。
   - `ReentrantLock`是在**JDK**层面实现的，`J.U.C(java.util.concurrent)`包中`locks`类的一个锁实现，需要显式创建，并通过调用`lock()`和`unlock()`方法来获取和释放锁。
2. 具体使用时，`ReentrantLock`相比`synchronized`增加了高级功能：
   - **等待可中断**：`ReentrantLock`提供了能够**中断等待锁的线程**的机制，（通过`lockInterruptibly()`实现）。具体是当前线程在等待获取锁的过程中，如果其他线程用`interrupt()`中断了当前线程，当前线程就会抛出`InterruptedException`异常，可以捕捉该异常进行相应处理。
   - **可实现公平锁**：`ReentrantLock`可以指定是公平锁还是非公平锁。而`synchronized`只能是非公平锁。`ReentrantLock`默认情况是非公平的，可以通过**有参构造方法**（`ReentrantLock(boolean fair)`）来指定锁是否公平。
   - **可实现选择性通知（锁可以绑定多个条件）**：`synchronized`和`wait()`和`notify()`/`notifyAll()`方法相结合，来实现等待/通知机制。`ReentrantLock`可以使用`Condition`接口的`newCondition()`方法实现等待机制，可以和多个`Condition`对象关联。
   - **支持超时**：`ReentrantLock`提供了一种非阻塞竞争锁的方法，`tryLock(timeout)`，可以指定自旋获取锁的最长时间，如果超过了设定时间，直接放回false。

从**原理层面**上看：

- `synchronized`是基于对象实现的，如果修饰方法，直接使用当前类作为锁（类锁），如果是同步代码块，就使用当前对象作为锁（对象锁）。
- `ReentrantLock`是基于AQS实现的。

在**性能层面**，如果竞争特别激烈，`synchronized`都会升级为重量级锁，`ReentrantLock`没有锁升级的机制，在这种情况下性能可能稍好。但是`ReentrantLock`仅仅是Java层面，`synchronized`在JVM层面，随着迭代效率可能会更好。

详细内容参考：

[Java并发常见面试题总结（中） | JavaGuide](https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#⭐️synchronized-和-reentrantlock-有什么区别)

[多线程与高并发 | ReentrantLock和synchronized的区别？--马士兵Java刷题班_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1XtiuewEnx/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)
