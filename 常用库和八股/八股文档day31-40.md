# 八股训练营

## Day31

### Case1

#### 题目：Java创建线程有哪几种方式？

**答案：**

在`Java`中，创建线程主要有以下几种方式：

1. **继承Thread类**：继承`Thread`类，并重写其`run`方法来定义线程执行的任务。缺点在于`Java`只支持单继承，所以继承`Thread`类成本很高。
2. **实现Runnable接口**：实现了`Runnable`接口，并重写其`run`方法。然后创建该类的**实例**作为参数传递给`Thread`对象。比继承的方式更灵活，但是这两种方式都无法在线程执行完之后返回值。
3. **使用Callable接口和FutureTask**：实现了`Callable`接口，并重写其`call`方法，该方法可以返回结果并抛出异常。将实现了`Callable`接口的类的实例，作为参数传递给`FutureTask`对象，再将`FutureTask`对象传递给`Thread`类，就可以使用**`start()`**方法启动线程。
4. **使用线程池**：前三种方法实际上都通过`new`一个`Thread`对象来创建线程，通过`Executors`类创建线程池，过程是向`ExecutorService`类对象传入一个实现了`Runnable`接口的对象，调用对象的`execute`方法。
5. **使用CompletableFuture类**：这是JDK1.8引入的类，可以用来执行异步任务。

虽然看上去创建线程的方法有很多，但是严格来说只有一种方法，因为这些方式最终都实现了`Runnable`接口，并且都依赖于`new Thread().start()`来创建线程。

详细内容参考：

[腾讯一面：请问java如何创建线程？创建线程的方式有几种？搞懵了。。_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Ru4y1n7Lw/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

[Java并发常见面试题总结（上） | JavaGuide](https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html#如何创建线程)

### Case2

#### 题目：线程start和run的区别

**答案：**

在Java多线程中，`run`方法和`start`方法的区别在于：

1. `start()`方法Java线程的内置方法，包含了创建新线程的代码逻辑，能够确保代码在**新线程**的上下文中运行。调用后会为线程分配系统资源，让线程处于就绪状态，调度器选择该线程时，会执行`run()`方法中的代码。一个线程在他的生命周期中**只能调用一次**`start()`方法，如果多次调用会抛出异常，表示该线程已经启动过了，不能再次启动。
2. 而`run()`方法是程序员定义的，是线程的执行体，不能创建新的线程，只会在**当前线程的**上下文中执行。如果直接调用`run()`方法，那只是一个**普通的方法调用**，仍然只有一个主线程，并且只能顺序执行，`run()`方法执行完成后才会执行后面的代码。

因此，`run()`方法并不会创建一个新的线程，如果需要实现多线程执行，需要调用`start()`方法来启动新线程。

详细内容参考：

[【Java高级】为什么启动线程不直接调用run()，而要调用start()，如果调用两次start()方法会有什么后果？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1s8411W7hV/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

## Day32

### Case1

#### 题目：你知道Java中有哪些锁吗

**答案：**

Java当中的锁主要是为了实现线程操作的原子性、有序性和可见性，来保证线程安全。主要有以下几类锁：

1. 从功能层面来说，只有<u>**共享锁**和**排他锁**</u>两类锁：共享锁可以被多个线程持有，排他锁一次只能被一个线程持有。Java中排他锁的具体实现就是`ReentrantLock`和`Synchronized`，`ReadWriteLock`则是**读写锁**的具体实现，当中的读锁是共享锁，写锁是排他锁。

2. 从看待并发同步的角度来说，可以分为<u>**乐观锁**和**悲观锁**</u>，他们并不是具体的锁的类型。
   - 悲观锁认为对于同一个数据的并发操作中，写操作比较多，很容易出现数据不一致的问题，所以在并发操作时，一定要**先获取锁**，才可以执行后面的操作。
   - 乐观锁则认为对同一个数据的并发操作中，写操作比较少，不容易出现数据不一致的问题，所以在并发操作时不需要先获取锁。在执行时选择**先修改**数据，再验证这段时间有没有**其他线程在修改**数据，如果没有，操作完成，如果有就放弃本次操作。乐观锁全程没有加锁，所以也可以叫无锁编程。

   从二者的描述可以看出，悲观锁适合写操作非常多的场景，防止数据冲突，在Java多数利用锁的场景都是悲观锁；乐观锁适合读操作非常多的场景，可以带来大量的性能提升，Java常见的乐观锁是**CAS算法**，比如原子类（`java.utl.concurrent.atomic`），通过CAS自旋实现原子操作的更新。

3. 从锁的状态来说，可以把锁分为**偏向锁、轻量级锁、重量级锁**，这三个概念在Java中是针对`Synchronized`来说的。
   在说明这三个锁之前，需要先明确加锁的本质是竞争同步状态或者静态变量，对`Synchronized`来说就是在**操作系统层面**竞争**Mutex机制**，期间会涉及内核指令的调用，带有内核态用户态切换的开销，为了减少这部分开销，出现了上述的三种锁：

   - **偏向锁**指的是一个线程获取锁时如果不存在竞争，那么锁会偏向这个线程，当线程下一次在进入时可以自动获取锁。
   - **轻量级锁**指的是当一个线程持有偏向锁时，另一个线程也尝试获取偏向锁，会升级为轻量级锁，这时其他线程会通过自旋的方式尝试获取锁，不会阻塞，也就没有内核态用户态的切换，提高了性能。
   - **重量级锁**则是我们常见的锁，一个线程没有获得锁时，自旋到一定次数会进入阻塞，这时锁也会升级为重量级锁。

4. **可重入锁**：一个线程在获取一个锁之后，线程内部再次获取这个锁可以直接获得，如果时不可重入锁，这样会发生死锁。Java中的`ReentrantLock`和`Synchronized`都是可重入锁。

5. **公平锁和非公平锁**：公平锁指多个线程按照**申请锁的顺序来获取锁**，非公平锁指线程获取锁的顺序并不是按照申请锁的顺序，会存在**线程之间的优先级**。Java中的`ReentrantLock`和`Synchronized`都是非公平锁。非公平锁虽然可能导致**优先级反转**或者**饥饿**现象，但是等待的时间更短，性能更好。

6. **分布式锁**：用于解决分布式架构下的粒度问题，对比`Synchronized`用于线程层面，分布式锁用于进程层面。

7. **分段锁**：分段锁不是具体的锁，是一种锁的设计，JDK1.7中`ConcurrentHashMap`就是通过分段锁实现并发操作的。

详细内容参考：

[10分钟彻底搞懂Java中的各种锁，接近天花板级别的回答！【Java知识分享】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Ju4y1P7Mf/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

### Case2

#### 题目：说一说你对synchronized的理解

**答案：**

`synchronized`是Java中的一个关键字，用于实现同步和线程安全。当一个**方法或代码块**被`synchronized`修饰时，它将成为一个临界区，同一时刻只能由一个线程访问，确保多个线程在访问共享资源时不会产生冲突。

- `synchronized`的底层是由`monitor`实现的，`monitor`是一个jvm级别的对象，所以`synchronized`可以在源文件被编译成为字节码时，在临界区前加上`MONITORENTER`表示进入临界区，临界区后加上`MONITOREXIT`表示离开临界区。
- `monitor`包含**`owner`、`entrylist`、`waitlsit`**三个属性，`owner`存储当前获得锁的线程；`entrylist`关联没有抢到锁，处于阻塞状态的线程；`waitlsit`关联调用了wait方法，处于等待状态的线程。
- `synchronized`实现的机制依赖于软件层面上的`JVM`，因此性能会随着JDK版本升级而提高。在`JDK1.6`之前，使用的都是**重量级锁**，也就是悲观锁。到了`JDK1.6`，引入了适应自旋、锁消除、锁粗化、偏向锁、轻量级锁还有锁升级等。锁升级具体流程如下：
  - 在一个临界区没有线程进入时，是无锁状态；
  - **偏向锁**是当一个线程要进入这个临界区，获取锁时如果不存在竞争，那么锁会偏向这个线程，该线程下一次在进入时可以自动获取锁。
  - **轻量级锁**指的是当一个线程持有偏向锁时，另一个线程尝试获取偏向锁，会升级为轻量级锁，这时其他线程会通过自旋的方式尝试获取锁，也就是`CAS`乐观锁。
  - 轻量级锁自旋了十次之后会升级为**重量级锁**，这时线程就会在未获得锁时阻塞。
- 在后续的升级中，因为**性能收益**并不明显，而且**代码维护成本**过高，`JDK15`默认关闭了偏向锁，而`JDK18`彻底废弃了偏向锁。
- 需要注意的是，当线程通过`synchronized`等待锁时是不能被`Thread.interrupt()`中断的，因此程序设计时要确保逻辑合理，否则可能会造成死锁。

- `Java`实现的锁机制有很多种，有些锁机制性能也比`synchronized`好，但是`synchronized`实现方便，依赖`JVM`来完成工作，可靠性高，所以只有在确定锁机制是当前多线程程序的**性能瓶颈**时，才考虑使用其他锁机制，比如`ReentrantLock`等。

详细内容参考：

[【大厂面试】聊聊你对Synchronized的理解_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1W3411K7PD/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

[并发编程篇-09-线程安全-synchronized关键字的底层原理-基础回答_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1yT411H7YK/?p=94&share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

[Java并发常见面试题总结（中） | JavaGuide](https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#synchronized-关键字)

## Day33

### Case1

#### 题目：synchronized和lock的区别是什么

**答案：**

`synchronized`和`lock`的区别主要有以下几点：

1. 从**功能**角度看，`synchronized`和`Lock`都是Java中用于实现线程同步的手段。
2. 从**特性**角度看
   - `synchronized`是Java的关键字，基于JVM的内置锁实现，可以用于修饰**方法**或**代码块**，不同的修饰位置**锁粒度**不同，而且可以通过`synchronized`加锁对象的生命周期来可控制作用范围，比如锁对象是**静态对象**或者**类对象**，那就是**全局锁**；如果是**普通对象**，作用域则取决于**对象的生命周期**。
   - 而`Lock`是java`J.U.C(java.util.concurrent)`包中的接口，有很多的实现类，比如说`ReentrantLock`。`Lock`是一种显式锁机制，需要手动获取和释放锁，也就是通过`lock()`方法和`unlock()`方法来控制锁的粒度。在两个方法之间的代码可以保证线程安全，而`Lock`实例的**生命周期**决定了锁的作用域。
3. **灵活性**区别：
   - ` lock`灵活性更高，可以自主决定加锁和释放锁的时机。还提供了**非阻塞竞争锁**的方法`trylock()`，可以返回`true/false`来表示锁是否被其他线程持有，如果返回false，可以选择**等待**或者**中断等待**。提供了超时机制，在一定时间内尝试获得锁，超时就放弃。
   - `synchronized`是关键字，无法实现非阻塞竞争锁，灵活性相对较低。`synchronized`锁的释放是被动的，只有代码或者方法**执行完成**或者**遇到异常**才会释放。而且`synchronized`方法一旦开始执行，即使线程被阻塞，也不能中断。没有超时机制，获取不到锁就会一直等待。
4. **公平锁/非公平锁**：`Lock`提供了公平锁和非公平锁的机制，`synchronized`只提供了非公平锁的实现。
5. **性能方面**：两者性能相差不大。
   - `synchronized`提供了**偏向锁、轻量级锁、重量级锁、锁升级**等机制来优化。还可以与`wait()`和`notify()/notifyAll()`方法一起使用，用于线程的等待和通知。
   - `Lock`使用**自旋锁**的机制进行优化。可以与`Condition`接口结合，实现更细粒度的线程等待和通知机制。
6. **使用场景**：`synchronized`适合锁的粒度较小、竞争不激烈、实现简单的场景。而`Lock`更加灵活，适用于需要更复杂的同步控制的场景。

详细内容参考：

[【Java面试】面试被问lock和synchronized的区别，如何回答轻松搞定面试官！_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1XS4y1S7W1/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

### Case2

#### 题目：synchronized和ReentrantLock的区别是什么

**答案：**

`synchronized`和`ReentrantLock`主要有以下几点区别：

在**使用层面**上：

1. `synchronized`和`ReentrantLock`都是Java中用于实现线程同步的手段，都是**可重入锁**。其中
   - `synchronized`是Java的关键字，基于**JVM的内置锁**实现，java中对于`synchronized`的优化都是JVM层面的，不会直接暴露给程序员。他可以用于修饰方法或代码块，是一个**对象锁**或者说**类锁**，使用时需要用到**堆内存**中存储的一个**对象**。
   - `ReentrantLock`是在**JDK**层面实现的，是`J.U.C(java.util.concurrent)`包中`locks`类的一个锁实现，需要显式创建，并通过调用`lock()`和`unlock()`方法来获取和释放锁。
2. 具体使用时，`ReentrantLock`相比`synchronized`增加了高级功能：
   - **等待可中断**：`ReentrantLock`提供了能够**中断等待锁的线程**的机制，（通过`lockInterruptibly()`实现）。具体是当前线程在等待获取锁的过程中，如果其他线程用`interrupt()`中断了当前线程，当前线程就会抛出`InterruptedException`异常，可以捕捉该异常进行相应处理。
   - **公平锁**：`ReentrantLock`可以指定是公平锁还是非公平锁。而`synchronized`只能是非公平锁。`ReentrantLock`默认情况是非公平的，可以通过**有参构造方法**（`ReentrantLock(boolean fair)`）来指定锁是否公平。
   - **选择性通知（锁可以绑定多个条件）**：`synchronized`和`wait()`和`notify()`/`notifyAll()`方法相结合，来实现等待/通知机制。`ReentrantLock`可以使用`Condition`接口的`newCondition()`方法实现等待机制，可以和多个`Condition`对象关联。
   - **支持超时**：`ReentrantLock`提供了一种非阻塞竞争锁的方法，`tryLock(timeout)`，可以指定自旋获取锁的最长时间，如果超过了设定时间，直接返回false。

从**原理层面**上看：

- `synchronized`是基于对象实现的，如果修饰方法，直接使用当前类作为锁（类锁），如果是同步代码块，就使用当前对象作为锁（对象锁）。
- `ReentrantLock`是基于AQS实现的。

在**性能层面**，如果竞争特别激烈，`synchronized`都会升级为重量级锁，`ReentrantLock`没有锁升级的机制，在这种情况下性能可能稍好。但是`ReentrantLock`仅仅是Java层面，`synchronized`在JVM层面，随着迭代升级，效率可能会更好。

详细内容参考：

[Java并发常见面试题总结（中） | JavaGuide](https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#⭐️synchronized-和-reentrantlock-有什么区别)

[多线程与高并发 | ReentrantLock和synchronized的区别？--马士兵Java刷题班_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1XtiuewEnx/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

## Day34

### Case1

#### 题目：volatile关键字的作用有哪些？

**答案：**

`volatile`关键字主要有以下两个作用：

1. **保证变量的可见性**：在Java当中，如果我们将变量声明为`volatile`，这就指示JVM，这个变量是共享且不稳定的，每次使用它都要到主存中进行读取。`volatile`关键字在 C 语言里也有，最原始的意义是**禁用 CPU 缓存**。在 C 语言中用`volatile`修饰变量，就是指示**编译器**，使用变量时都到主存中进行读取。Java中`volatile`是具体机制如下：
   - 当对非`volatile`变量进行读写的时候，每个线程先从**主内存**拷贝变量到**`CPU`缓存**中，如果计算机有多个`CPU`，每个线程可能在不同的`CPU`上被处理，这意味着**变量**可以拷贝到不同的`CPU cache`中。
   - 而`volatile`变量不会被缓存在寄存器或者对其他处理器不可见的地方（也就是`CPU cache`），保证了每次读写变量都从**主内存**中读，跳过`CPU cache`这一步。当一个线程修改了这个变量，其他线程可以立刻得知新的值。
2. **禁止指令重排序**：指的是**防止 JVM 的指令重排序**，对`volatile`变量进行读写操作的时候，会通过插入特定的**内存屏障**来禁止指令重排序：
   - 指令重排序是`JVM`为了优化指令、提高程序运行效率，在不影响**单线程程序**执行结果的前提下，尽可能地**提高并行度**， 包括**编译器重排序**和**运行时重排序**；
   - 针对`volatile`修饰的变量，会在读写操作指令前后会插入**内存屏障**，指令重排序时不能把后面的指令重排序到内存屏障中。
3. **无法保证原子性**：线程安全主要分为原子性、可见性和有序性。虽然`volatile`可以确保**可见性**，但它不保证复合操作的**原子性**。比如对一个变量进行自增操作，需要先读取变量、对变量加一、把变量写回，`volatile`可以保证写回变量之后其他线程立刻看到，但是无法保证这三个操作的原子性。

详细内容参考：

[Java并发常见面试题总结（中） | JavaGuide](https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#⭐️volatile-关键字)

### Case2

#### 题目：volatile与synchronized的对比

**答案：**

`volatile`和`synchronized`都是Java中用于多线程同步的工具，他们是两个互补的存在，之间存在一定的区别：

**机制和用途**

- `synchronized`：用于修饰**方法或代码块**，当一个线程进入一个由`synchronized`修饰的代码块或方法时，它会获取一个**监视器锁**，这保证了同一时间只有一个线程可以执行这段代码。其主要用途是**确保数据的一致性和线程安全性**。
- `volatile`：用于修饰**变量**。当一个线程修改了`volatile`变量的值，其他线程能够立即看到这个修改，也就是说`volatile`的主要作用是确保**变量的可见性**。此外，它还可以**防止指令重排序**。但是，`volatile`并不能保证复合操作的原子性。
- 综上，`volatile`关键字主要用于解决变量在多个线程之间的可见性，而`synchronized`关键字解决的是多线程访问共享资源的同步问题。

两者都是多线程同步的工具，在**多线程同步的三个特性**上也有一定区别：

1. **原子性**：
   - ` volatile`：不能保证同一时间只有一个线程操作变量，所以无法保证复合操作的原子性，比如自增、自减等。
   - `synchronized`：是排他锁，被其修饰的方法或代码块在执行过程中不会被其他线程打断，保证了他们的原子性。
2. **有序性**：
   - `synchronized`是以程序的串行化执行来保证有序性，被`synchronized`修饰的代码块中的**代码指令可以被重排序**。
   - 对`volatile`变量进行读写操作的时候，会在读写操作前后插入**内存屏障**，指令重排序时不能把后面的指令重排序到内存屏障中。
3. **可见性**：
   - `volatile`使用**机器指令lock**将修改后的**工作内存**中的数据强制刷新到**主内存**，并且使其他线程的工作内存中的`volatile`数据失效，保证了可见性。
   - `synchronized`借助**JVM指令`MONITORENTER`**和**`MONITOREXIT`**使代码串行化，其中**`MONITOREXIT`**时所有共享资源都会刷新到主内存中，保证了可见性。

**性能与使用场景**：`volatile`通常比`synchronized`更轻量级，不涉及锁的获取和释放，相对来说性能更好，但是也意味着它提供的**同步级别较低**。
所以`volatile`适用于**简单的内存可见性要求**，而`synchronized`适用于**更复杂的同步场景**。

详细内容参考：

[请说说volatile和synchronized的区别？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1a5411R7Yc/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

### Case3

#### 题目：JDK8有哪些新特性

**答案：**

1. **接口的默认方法**：为了适配`Lambda`表达式，允许在接口中实现方法，需要使用`default`或者`static`关键字。

2. **`Lambda`表达式**：允许以**更简洁的语法编写匿名函数**。

   ```java
   Collections.sort(names, new Comparator<String>() {
       @Override
       public int compare(String a, String b) {
           return b.comparaTo(a);
       }
   });
   // Lambda表达式如下：
   Collections.sort(names, (String a, String b) -> { return b.compareTo(a); });
   // 或者简短点：
   Collections.sort(names, (String a, String b) -> b.compareTo(a));
   // 让java编译器自动推导参数类型：
   Collections.sort(names, (a, b) -> b.compareTo(a));
   ```

3. **函数式接口**：函数式接口仅仅包含一个抽象方法，除此以外还可以有默认方法和静态方法，可以用`@FunctionalInterface`注解修饰。通常可以用Lambda表达式进行实例化来简化编程。

4. **`Stream API`**：JDK1.8之前的Stream大多是资源流，比如`FileInputStream`，只负责**搬运数据**。`Stream API`依然不存储数据，但是可以对**集合数据**进行映射、排序、筛选、统计等。

5. `Date-Time API`：JDK1.8引入了`java.time`包，提供了全新的日期和时间`API`。它解决了旧的`java.util.Date`和`java.util.Calendar`的诸多问题，比如**非线程安全**、**时区处理麻烦**等，并提供了更加清晰和易用的日期和时间处理方式。

6. **方法引用**：允许通过方法的名称来**引用一个方法**，而不是执行它。可以更简洁地**把方法作为参数传递**。比如`System.out::println`。

详细内容参考：

[Java8 新特性实战 | JavaGuide](https://javaguide.cn/java/new-features/java8-common-new-features.html#date-time-api)

[超解析！最新八股“JDK1.8的新特性有哪些？”教你吊打面试官！！！_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV12f4y1o7is/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

## Day36

### Case1

#### 题目：为什么要有线程池？

**答案：**

使用线程池主要有几下几个原因：

1. **资源管理**：在多线程应用中，每个线程都需要占用内存和CPU资源，如果不限制线程的创建，可能导致系统**资源耗尽**，引发系统崩溃。线程池可以限制并控制线程的数量，避免这个问题。
2. **提高性能**：线程池可以**重用**已存在的线程，减少创建和销毁线程的开销，任务也可以不等待线程创建就能立即执行。
3. **任务调度**：线程池可以对线程进行监控、调度和管理，可以与任务队列相互配合，合理分配任务，避免线程竞争和冲突。

除此以外，为了应对不同的场景，有多种不同的线程池，可以通过`ThreadPoolExcutors`或者`Executors`构造，其中`Executors`创建线程池主要有以下几种方法：

1. `newFixedThreadPool`：**固定线程数量**的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时执行。
2. `newSingleThreadPool`：**只有一个线程**的线程池。数量超过一的任务被提交到该线程池后，任务会被保存在无界任务队列中，按先入先出的顺序执行队列中的任务，任务执行完线程也不会释放。
3. `newCachedThreadPool`：**核心线程数为0**，最大线程数是`Integer.MAX_VALUE`，所有线程都是**救急线程**。若所有线程都在工作时，又有新的任务提交，则会创建新的线程，因为他的队列是**`SynchronousQueue`**实现的，有**空闲线程时才能存入任务**。线程执行完任务时会返回线程池复用，但是会在60s后回收。
4. `ScheduledThreadPool`：可以设定**延迟指定时间**后执行任务，也可以**周期性执行任务**，还可以在一个任务执行**完成后**，延迟一定时间，再执行下一个任务。

综上，线程池不仅可以管理系统资源，还可以针对不同的情况创建不同的线程池。需要注意的是《阿里巴巴 Java 开发手册》中强制线程池不允许使用`Executors`去创建，而是通过`ThreadPoolExecutor`构造函数创建。因为`Executors`返回的线程池对象，大多数任务队列或者允许创建的线程数量上限都是`Integer.MAX_VALUE`，容易导致OOM。

------

原因是`Executors`返回的线程池对象存在一些弊端：

- `FixedThreadPool`和`SingleThreadExecutor`：使用**有界阻塞队列**（`LinkedBlockingQueue`），其任务队列的最大长度为`Integer.MAX_VALUE`，可能堆积大量的请求，从而导致OOM。
- `CachedThreadPool`：使用的是**同步队列**`SynchronousQueue`，允许创建的线程数量是`Integer.MAX_VALUE` ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致OOM。
- `ScheduledThreadPool`：使用的无界的**延迟阻塞队列**`DelayedWorkQueue`，任务队列最大长度为`Integer.MAX_VALUE`，可能堆积大量的请求，从而导致OOM。

详细内容参考：

[高频面试题：你工作中什么场景使用什么线程池，为什么_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1wG4y1T71m/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

[腾讯一面：java有几种线程池？常见的线程池有哪几种？分别说一下。。_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1hg4y1r7qx/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

[Java并发常见面试题总结（下） | JavaGuide](https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#⭐️为什么要用线程池)

### Case2

#### 题目：说一说线程池有哪些常用参数

**答案：**

线程池的常用参数主要有以下几个：

其中**最重要的参数**有三个：

1. `corePoolSize`**核心线程数**：线程池中**长期存活**的线程数，也是线程池中最少的线程数。当**任务队列未满**时，池中存在的线程数量。
2. `maximumPoolSize`**最大线程数**：线程池允许创建的**最大线程数量**，当线程池的**任务队列满**了之后，可以创建**救急线程**，这时线程总数不能超过最大线程数。
3. `workQueue`**线程池任务队列**：线程池中存放任务的队列，新任务到来时会先判断当前**正在运行**的线程数量是否达到核心线程数，如果达到，新任务会被存放在队列中。

其他的常见参数有：

- `keepAliveTime`**空闲线程存活时间**：当线程数大于核心线程数时，多余的空闲线程不会立即销毁，会等待直到时间超过`keepAliveTime`才会被回收。
- `TimeUnit`：与`keepAliveTime`一起使用，指定`keepAliveTime`的**时间单位**，如秒、分钟等。
- `ThreadFactory`**线程工厂**：线程池创建线程时调用的工厂方法，可以设置线程的**优先级**、线程**命名规则**以及线程**类型**（用户线程还是守护线程）等。
- `RejectedExecutionHandler`**拒绝策略**：当线程池**任务队列**存满之后，对于新提交的任务执行的策略。有以下几种策略：
  - **`ThreadPoolExecutor.AbortPolicy`**：抛出`RejectedExecutionException`来拒绝新任务的处理。
  - **`ThreadPoolExecutor.CallerRunsPolicy`**：将任务回退给**调用的线程**执行，如果该线程已关闭，会丢弃该任务。但是这种策略会**降低新任务的提交速度**，并且如果是回退给**主线程**，任务又比较**耗时**，可能会导致主线程阻塞，影响程序的整体性能。
  - **`ThreadPoolExecutor.DiscardPolicy`**：不处理新任务，直接丢弃掉。
  - **`ThreadPoolExecutor.DiscardOldestPolicy`**：此策略将丢弃**最早的未处理**的任务请求。

详细内容参考：

[请解释一下线程池7个参数的含义？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1KQ4y1S7uc/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

[Java并发常见面试题总结（下） | JavaGuide](https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#⭐️线程池常见参数有哪些-如何解释)

### Case3

#### 题目：BIO、NIO、AIO的区别

**答案：**

UNIX系统下I/O模型一共有5种：**同步阻塞I/O，同步非阻塞I/O、I/O多路复用、信号驱动I/O、异步I/O**。因为用户空间的程序不能直接访问内核空间，所以用户进程要执行IO操作，就要通过**系统调用**来让内核完成IO操作。

而`BIO`、`NIO`、`AIO`是Java当中常见的三种IO模型。：

- `BIO`是**同步阻塞I/O**，应用程序发起read调用后，会一直阻塞，直到**内核**把数据**拷贝到用户空间**。就好像我的面前有一排水壶在烧水，而我一次只能盯着一个水壶，直到这个水壶的水烧开了之后才能查看别的水壶。所以显而易见他**不适合**处理**大量的连接**。
- `NIO`是**同步非阻塞I/O**，在JDK1.4引入，对应`java.nio`包，提供了`Channel`、`Selector`、`Buffer`等抽象类，支持面向缓冲，基于通道的I/O操作方法。
  在模型中，应用程序会一直发起read调用，如果内核一直在**准备数据或者数据就绪**阶段，就会一直轮询，直到数据**开始拷贝**，才会进入阻塞，直到拷贝完成。这样的问题在于，应用程序在**轮询数据**时，会不断进行**I/O系统调用**，十分消耗 CPU 资源的。
  所以`NIO`还可以使用`Selector`实现**I/O多路复用**，线程会先发起select调用，轮询内核数据是否就绪，就绪之后再发起read调用，减少了无效的系统调用。
- `AIO`是JDK1.7引入的`NIO`改进版，是**异步I/O**模型，基于**事件和回调机制**实现。应用操作之后会直接返回，不会堵塞，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

- 使用场景：
  - `BIO`适合低并发、连接数较少的应用。
  - `NIO`适合高并发、需要处理大量连接的应用。
  - `AIO`适合需要高性能、异步处理I/O操作的场景。

详细内容参考：

[Java IO 模型详解 | JavaGuide](https://javaguide.cn/java/io/io-model.html#前言)

[中级面试题：BIO、NIO、AIO之间的区别以及各自的应用场景？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1MW4y1Y7eQ/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

## Day37

### Case1

#### 题目：Java内存区域有哪些部分

**答案：**

Java的内存区域主要六个部分，其中线程私有的是**虚拟机栈**、**本地方法栈**、**程序计数器**，线程之间共有的是**堆**、**方法区**、**直接内存**，其中方法区在JDK1.8时被改称为**元空间**，并且从运行时数据区移到了本地内存。

1. **程序计数器**：程序计数器是一块**较小的内存空间**，可以看作是当前线程所执行的字节码的**行号指示器**。在多线程环境下，每个线程都有自己**独立**的程序计数器。当线程运行时，程序计数器记录的是正在执行的**虚拟机字节码指令的地址**。

2. **Java虚拟机栈**：栈的**生命周期**与线程相同，随着线程创建而创建，随线程死亡而死亡。除了一些**Native方法**回调用本地方法栈，其他**所有Java方法**调用都通过栈来实现。每一次方法调用都会有**对应的栈帧**压入栈，用于存储**局部变量表**、**操作数栈**、**动态链接**、**方法返回地址**等信息。方法调用结束之后，对应栈帧弹出。

   栈可能会出现两种错误：

   - **`StackOverFlowError`：** 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出`StackOverFlowError`错误。
   - **`OutOfMemoryError`：** 如果栈的内存大小可以动态扩展， 但是虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。

3. **本地方法栈**： 本地方法栈与Java虚拟机栈类似，但它为虚拟机使用的**本地方法**服务。本地方法是用其他编程语言（如C/C++）编写的，Java代码可以通过`JNI(Java Native Interface)`调用本地方法。运行时也可能会出现和栈类似的两种错误。

4. **堆**：堆是JVM中最大的内存区域，在JVM启动时创建，用于**存储对象实例**。**几乎**所有的**对象实例**和**数组**都在堆上分配内存，随着**`JIT`**（Just In Time编译器，即使编译器）发展和**逃逸分析技术**成熟，JDK1.7默认开启逃逸分析，某些方法中的对象引用没有被返回或者被外部使用，可以直接在**栈上分配内存**。
   堆是**垃圾收集器**管理的主要区域，所以也被成为**GC堆**。而GC通常采用分代垃圾回收算法，所以把堆分为**新生代**、**老生代**、**永久代**等区域，（其中新生代又包括Eden空间、Survivor空间（From和To））。其中永久代在JDK1.8被**元空间**取代。

5. **方法区**： 用于存储已被虚拟机加载的**类信息、常量、静态变量、即时编译器编译后的代码**等数据。方法区、永久代和元空间之间的关系很像类和接口的关系，可以把**方法区看作接口**，**永久代**是JDK1.8之前实现接口的**类**，元空间是JDK1.8及以后的实现类。元空间之所以取代永久代主要有以下几个原因：

   - 永久代的大小受**JVM内存**的限制，而元空间使用**本地内存**，受可用内存限制。
   - 数据进入永久代并非“永久存在”，会为GC带来不必要的复杂度。

6. 运行时常量池：是**方法区**的一部分，用于存储编译期生成的类、方法和常量等信息。

7. 字符串常量池：是JVM为了提升性能和减少内存消耗针对**字符串**专门开辟的一块区域，主要目的是为了**避免字符串的重复创建**。在JDK1.7放入**堆**中，提高了回收效率。

8. 直接内存：不是Java虚拟机运行时数据区的一部分，通过`JNI`在本地内存上分配，Java可以通过NIO直接操作。

------

堆中对象的年龄变化以及新生代老生代查看详细内容参考

详细内容参考：[Java内存区域详解（重点） | JavaGuide](https://javaguide.cn/java/jvm/memory-area.html#前言)

[【java】jvm内存模型全面解析_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV12t411u726/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

### Case2

#### 题目：介绍一下什么是强引用、软引用、弱引用、虚引用

**答案：**

这四种引用决定了对象的**生命周期**以及垃圾收集器如何**回收垃圾**。

1. **强引用**：普通对象的引用，是最常见的引用类型。如果有强引用指向一个对象，那么垃圾收集器就不会回收它。没有其他引用，或者超过了引用的作用域，又或是显式地把引用赋值为null，才可以进行内存的回收。
2. **软引用**：软引用用于描述一些**还有用但非必需**的对象。如果一个对象只有软引用指向它，那么在**系统内存不足**时，垃圾收集器会尝试回收这些对象。软引用通常用于实现**内存敏感的缓存**，可以在内存不足时释放缓存中的对象。
3. **弱引用**：弱引用比软引用的生命周期更短暂。如果一个对象只有弱引用指向它，在进行下一次垃圾回收时，不论系统内存是否充足，这些对象**都会被回收**。弱引用通常用于实现对象缓存，但不希望缓存的对象影响垃圾回收的情况。
4. **虚引用**：虚引用提供了对象**被回收后执行某些操作**的机制。如果一个对象只有虚引用指向它，那么它**随时**都可能被垃圾回收器回收，但在对象被回收之前，虚引用会被放入一个队列中，程序可以通过这个队列中的虚引用判断该对象是否要被回收，可以在回收前执行一些操作。虚引用主要用于记录对象被垃圾回收的时机。

详细内容参考：

[【Java面试】资深Java工程师必问面试题，强引用、软引用、弱引用、虚引用有什么区别？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1ST411J7Bk/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

### Case3

#### 题目：有哪些垃圾回收算法

**答案：**

Java中主要有以下几种垃圾回收算法：

1. **标记-清除算法**（Mark-and-Sweep）

   标记-清除算法把垃圾回收分为两个阶段：标记（Mark）阶段和清除（Sweep）阶段：

   - **标记阶段**：首先通过根节点(GC Roots)进行**可达性分析**，标记所有不需要回收的对象，未被标记的就是未被引用的垃圾对象。
   - **清除阶段**：在标记完成后回收所有未被标记的对象。 

   这时最基本的回收算法，很明显会带来两个问题：

   1. **效率问题**：标记和清除两个过程效率都不高。
   2. **空间问题**：标记清除后会产生大量不连续的内存碎片。

2. **复制算法**

   为了解决标记-清除算法的效率和内存碎片问题，出现了复制算法。它将内存分为**大小相同的两块**，每次使用**其中一块**。当这一块的内存使用完后，就将还存活的对象**复制**到另一块去，然后再把使用的空间一次回收。这样每次的内存回收都是对内存区间的一半进行回收。
   比较适用于存活对象较少的情况，比如堆中的**新生代**，因为新生代中98%的对象基本是“朝生夕死”。
   虽然改进了标记-清除算法，但是还有以下**问题**：

   1. **可用内存变小**：可用内存缩小为原来的一半，而且需要复制内存。
   2. **不适合老年代**：如果存活对象数量比较大，复制性能会变得很差。

3. **标记-整理算法**（Mark-and-Compact）

   标记-整理算法是根据**老年代的特点**提出的一种标记算法，标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象回收，而是将所有存活的对象**压缩到内存的一端**，然后直接清理掉**边界以外**的内存。
   优点在于避免了碎片的产生，也没有降低内存的利用效率。但是因为多了**整理**的步骤，效率不高，比较适用于堆中的**老生代**。

4. **分代收集算法**

   不同的对象**存活周期**各不相同，而不同的算法针对不同存活周期的对象也表现出不同的效率。所以JVM的垃圾收集器都会将对象划分为**新生代（Young Generation）**和**老生代（Tenured Generation）**（堆之外还有一个永久代（Permanet Generation）），对他们使用不同的回收算法。新生代**存活率低**，可以使用**复制**算法（Eden、S1、S2，通常只有一个S中的对象是存活的，8：1：1）。而老年代**存活率高**，而且**没有额外空间**对它进行分配担保，所以使用**标记清除**或者**标记整理**算法。

5. 分区收集算法

   把整个对空间分为连续的小区间，每个小区间独立使用，独立回收，优势在于可以控制一次回收多少小区间，也就可以控制一次GC的时间。常见的应用是**G1收集器**。

详细内容参考：

[Java面试满分回答——知道JVM哪些垃圾回收器？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1jV4y1X7At/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

[JVM垃圾回收详解（重点） | JavaGuide](https://javaguide.cn/java/jvm/jvm-garbage-collection.html#堆空间的基本结构)

### Case4

#### 题目：有哪些垃圾回收器

**答案：**

Java堆是垃圾收集器管理的主要区域，堆中的对象又被分为新生代和老生代，所以Java当中的垃圾收集器也可以按照使用范围是新生代和老生代分类：

1. **新生代**垃圾收集器，采用**标记-复制**算法

   - **`Serial`收集器**是最基本、历史最悠久的垃圾收集器，是**单线程**收集器。缺点在于回收垃圾时，必须暂停其他所有的工作线程（"Stop The World"），直到收集结束。优点则是在**单线程**这方面比其他的收集器**简单高效**。
   - **`ParNew`收集器**是`Serial`收集器的**多线程**版本，除了多线程以外和`Serial`收集器**完全一样**。是许多服务器模式下虚拟机的首要选择，因为只有他和`Serial`收集器可以和`CMS`收集器配合工作。
   - **`Parallel Scavenge`收集器**，也是**多线程**收集器。追求高吞吐量，高效利用 CPU。

2. **老年代**垃圾收集器

   - **`Serial Old`收集器**，是`Serial`收集器的老年代版本，它同样是一个**单线程**（串行）收集器，使用**标记-整理算法**。在JDK1.5及以前的版本中与`Parallel Scavenge`收集器搭配使用，也可以作为`CMS`收集器的后备方案。

   - **`Parallel Old`收集器**是`Parallel Scavenge`收集器的老年代版本，是**多线程**收集器，使用**标记-整理算法**。在JDK1.6引入，追高**吞吐量**。

   - **`CMS(Concurrent Mark Sweep)`收集器**是一种以获取**最短回收停顿时间**为目标的收集器，是第一个真正意义上的**并发收集器**，实现了**垃圾收集线程**和**用户线程**基本上同时工作。因为它的系统停顿时间最短，适合在**注重用户体验**的应用上使用。
     `CMS`收集器是基于**标记-清除算法**实现的，它的运作过程相对前面几种收集器来说更复杂一些，分为4个步骤：

     - **初始标记**：短暂停顿，标记直接与GC root相连的对象；
     - **并发标记**：同时开启GC和用户线程，用一个**闭包**结构去记录可达对象。因为用户线程会不断的**更新引用域**，所以无法保证可达性分析的实时性，所以还会跟踪记录**发生引用更新**的地方。
     - **重新标记**：会修正**并发标记期间发生引用更新**的记录，该阶段停顿时间会比**初始标记**的时间稍长，远远比**并发标记**时间短
     - **并发清除**：开启用户线程，同时GC线程开始回收未标记的区域。

     `CMS`收集器的问题在于对CPU资源敏感；回收结束会产生大量空间碎片。在Java9被标记为过时，Java14中被移除。

3. **新生代和老年代**垃圾收集器

   - **G1(Garbage-First)收集器**，是一款**面向服务器**的垃圾收集器，主要针对配备**多颗处理器**及**大容量内存**的机器。以极高概率满足GC停顿时间要求的同时，还具备**高吞吐量**性能特征。JDK1.7引入，在JDK1.9成为默认垃圾收集器。主要有以下特征：
     - **并行与并发**：G1能充分利用**多个CPU**（CPU 或者 CPU 核心）的硬件优势来缩短停顿时间。部分其他收集器需要**停顿**Java线程执行的GC动作，G1收集器可以通过**并发**的方式维持java程序执行。
     - **分代收集**：G1保留了**分代**的概念，可以同时**兼顾**新生代和老年代。
     - **分许算法**：不要求新生代、老年代的空间连续。
     - **空间整合**：G1从**整体**来看基于**标记-整理**算法；从**局部**上来看是基于**标记-复制**算法，减少空间碎片。
     - **可预测的停顿**：G1除了追求**低停顿**，可选取**部分区域**进行回收，可以缩小回收范围，**减少全局停顿**。
   - **G1收集器的阶段分以下几个步骤:**
     - **初始标记**：标记从GC Root开始**直接可达**的对象，会有短暂停顿。
     - **并发标记**：与应用并发运行，标记所有可达对象。可能持续较长时间。
     - **最终标记**：修正那些在**并发标记发生变化的**对象，会短暂停顿。
     - **筛选回收**：根据**标记**和用户所期待的**GC停顿时间**指定回收计划，优先回收垃圾多的区域，因为这些区域需要复制的对象较少。

详细内容参考：

[JVM垃圾回收详解（重点） | JavaGuide](https://javaguide.cn/java/jvm/jvm-garbage-collection.html#垃圾收集器)

[【5分钟背八股】118：JVM有哪些垃圾回收器，实际中如何选择？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1ba411K75n/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)











