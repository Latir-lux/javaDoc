# 八股训练营

## Day22

### Case1

#### 题目：介绍一下Redis缓存雪崩和缓存穿透，如何解决这些问题？

**答案：**

目前大多数数据库都是由**Redis和MySQL协同合作**的，Redis负责**缓存**，MySQL负责**存储**。请求数据的流程是先访问Redis，如果Redis有数据直接返回，没有的话就需要查询数据库，然后数据库**返回结果并把数据同步**到Redis。但是MySQL是基于磁盘的，承担不了大量请求。所以**缓存异常**时，大量请求**直接访问数据库**就会出问题，主要情况有三种：

1. **缓存雪崩**：为了保证**缓存**中数据和**数据库**中数据的**一致性**，通常会给Redis中的数据设置过期时间，数据过期之后，请求就会**直接访问数据库**。那么当大量缓存数据在同一时间过期或者Redis故障宕机时，数据库就会压力骤增，系统崩溃，这就是缓存雪崩。
   当大量数据同时过期导致雪崩时，处理方式有以下几种：

   - **设置不同过期时间**：对缓存中数据设置过期时间时，可以给过期时间加上一个**随机数**。
   - **设置互斥锁**：如果请求的数据不在Redis中，在请求访问数据库时需要**获取互斥锁**，确保同一时间只有一个请求访问，最好给互斥锁设置**超时时间**，防止出现问题阻塞整个系统。
   - **后台更新缓存**：可以设置缓存**“永久有效”**，也就是将更新缓存的工作交给后台线程，后台线程可以**不断检测缓存是否有效**，也可以在**业务线程**发现缓存失效后通过**消息队列通知后台线程**。

   因为Redis故障宕机而雪崩的处理方式有以下几种：

   - **服务熔断或者请求限流机制**：可以启动服务熔断机制，**暂停对缓存的访问**，直接**返回错误**；或者请求限流，只将**少部分请求**发送到数据库，其余请求直接**拒绝**。
   - **构建Redis缓存高可靠集群**：服务熔断和请求限流是雪崩发生后的方案，发生前可以用**主从节点**的方式构建集群，**主节点宕机后切换到从节点**。

2. **缓存击穿**：业务中通常会有几个数据被**频繁的访问**，这些数据就是**热点数据**。如果某个**热点数据过期**了，大量请求会直接访问数据库，导致数据库被**高并发请求冲垮**，这就是缓存击穿。
   缓存击穿和缓存雪崩很相似，所以他们处理方式也很类似：

   - **互斥锁方案**：同一时间只允许一个业务线程更新缓存。
   - **后台更新缓存**：用**后台线程**异步更新热点数据，或者在数据快过期之前，通知后台线程更新缓存。

3. **缓存穿透**：如果用户要访问的数据，**不在缓存中**，**也不在数据库中**，那么数据库没办法构建缓存，大量这样的请求到来时，数据库压力骤增，就是缓存穿透。
   常见的原因有两种，**业务误操作**，删除了缓存和数据库中的数据；或者是**黑客恶意攻击**，故意读取不存在的数据。常见应对方案有三种：

   - **限制非法请求**：在API入口处判断**请求参数是否合理**，如果包含非法值直接**返回错误**。
   - **缓存空值或者默认值**：针对查询的数据**缓存一个空值或默认值**，后续的请求会直接从缓存中读取空值或默认值。
   - **布隆过滤器**：布隆过滤器由**位图数组**和**N个哈希函数**组成，往数据库写入数据时，过滤器使用N个哈希函数计算出N个哈希值，找到位图数组中对应的**N个位置将他们置1**，有请求访问数据库时，查询对应数据的N个位置，**全为1则访问数据库**，否则不访问。布隆过滤器认为存在，数据不一定存在，但是**过滤器认为不存在，则数据一定不存在**。

详细内容参考：

[什么是Redis缓存雪崩、穿透、击穿，十分钟给你讲的明明白白_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1f5411b7ux/?share_source=copy_web&vd_source=db4b8256b37979f4e7f296b129aaaf87)

[什么是缓存雪崩、击穿、穿透？ | 小林coding](https://xiaolincoding.com/redis/cluster/cache_problem.html#缓存雪崩)

### Case2

#### 题目：如何保证数据库和缓存的一致性

**答案：**

保证数据库和缓存的一致性的第一个问题是，缓存是**更新还是删除**。

如果**更新缓存**，由于缓存不会适合加锁，那么无论是先更新数据库还是先更新缓存，有**多个请求并发更新同一条**数据时，都容易出现数据不一致现象，所以一般不更新缓存。

**Cache Aside**：如果选择**删除缓存**，那么就是**Cache Aside策略（旁路缓存策略）**，这时**多条更新同一个数据**的请求相互之间没有威胁，因为缓存最终都会被删除，有冲突的是**写策略和读策略**。读策略在**缓存未命中**时会从数据库把数据写回缓存，这时如果我们**先删除缓存再更新数据库**，可能会导致读策略把旧数据写入缓存，因为**数据库写入比缓存写入要慢很多**，所以反过来**先更新数据库，再删除缓存**，出问题的概率会小很多。

但是Cache Aside还会出现别的问题，常见的就是最后**删除缓存的操作失败了**，这样子只能等**下次更新**或者**缓存过期**才会恢复正常。这个问题的解决方案有：

- **消息队列**：将要删除的缓存数据加入到消息队列，如果删除缓存失败了，会从消息队列中读取数据再次删除，这就是**重试机制**，如果成功了就把数据从消息队列中删除。
- **订阅binlog**：阿里巴巴开源的**Canal中间件**的作用是模拟出一个从节点，向主节点发送dump请求，接收binlog后转化为**结构化数据**，然后根据log删除缓存，**删除成功后发送ACK确认删除**。

除了Cache Aside还有两种保证一致性的方法。

**Read/Write Through**

- **原理**：原理是把更新数据库（Repository）的操作由**缓存代理**。
- **Read Through**：就是在**查询操作**中更新缓存，Cache Aside策略是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对调用方是透明的。
- **Write Through**：在数据更新的时候，如果没有命中缓存，就只更新数据库。如果命中了缓存，则更新缓存，然后再由缓存服务更新数据库。

**Write Behind**

- **原理**：在更新数据的时候，只更新缓存，不更新数据库，而缓存会异步地批量更新数据库。这个设计的好处就是让数据的I/O操作非常快，带来的问题是，数据不是强一致性的，而且可能会丢失。

详细内容参考：

[帮面试官写代码，我被录用了，数据库与缓存的数据一致性问题分析_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1dU4y1f7Pa/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

[数据库和缓存如何保证一致性？ | 小林coding](https://xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#数据库和缓存如何保证一致性)

## Day23

### Case1

#### 题目：String、StringBuffer、StringBuilder的区别

**答案：**

`String`, `StringBuilder`, 和 `StringBuffer` 都是Java中用于处理字符串的类，但它们之间有一些重要的区别：

1. 不可变性

   - `String`内部的**字符数组**使用 **`final`** 修饰，为不可变的字符串类，每当我们对`String`对象进行改变时，实际上都会创建一个新的 String 对象，旧的`String`对象会被 JVM 回收，**频繁更改**容易触发后台 **`gc`**，引起系统内存抖动。
   - `StringBuilder`和`StringBuffer`都继承自`AbstractStringBuilder`类，也使用字符数组保存字符串，但是没有使用`final`和`private`修饰，是可变的。它们在修改字符串时不会创建新的对象。

2. 线程安全

   - `String`：由于`String`是不可变的，是常量，所以是**线程安全**的。
   - `StringBuffer`中的方法均使用**`synchronized`**关键字修饰，是**线程安全**的。
   - 而`StringBuilder`没有给方法加**同步锁**，**线程不安全**。

3. 性能

   `String`每次改变时都要生成一个新的对象，所以对于复杂的字符串操作，比如**频繁的拼接、插入、删除**，`StringBuilder`和`StringBuffer`效率高于`String`。

4. 使用场景

   - `String`: 字符串**不经常变化**的场景中可以使用 `String` 类，例如常量的声明、少量的变量运算。
   - `StringBuilder`: 在**单线程**的环境中，频繁进行**字符串运算**（如拼接、替换、和删除等），则可以考虑使用`StringBuilder`，如SQL语句的拼装、JSON封装等。
   - `StringBuffer`: 在**多线程**环境中，频繁进行字符串运算（如拼接、替换、删除等），则可以考虑使用 `StringBuffer`，例如`XML`解析、`HTTP`参数解析和封装。

详细内容参考：

[Java基础常见面试题总结(中) | JavaGuide](https://javaguide.cn/java/basis/java-basic-questions-02.html#string、stringbuffer、stringbuilder-的区别)

[【2分钟搞定八股文面试题】①String、StringBuffer、StringBuilder的区别_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1hT4y1S7K4/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

### Case2

#### 题目：接口和抽象类的区别

**答案：**

1. **设计目的**

   - **接口用于定义规范**，对类的行为进行约束，实现某个接口就有了对应的行为。

   - **抽象类用于代码复用**，提供通用的实现或基础功能，强调的是所属关系。

2. **定义**

   - 接口是一种**抽象类型**，它定义了一组方法，但没有实现任何方法。接口中的方法默认是**抽象方法**，且接口中**成员变量**只能是**`public static final`**类型的。

   - 抽象类是一个**类**，可以包含**抽象方法和具体方法**，也可以包含**普通成员变量和常量**。

3. **继承和实现**

   接口和抽象类都不能**直接实例化**，需要子类实现他们的抽象方法后**实例化子类**。

   - 一个接口可以继承多个其他接口，一个类可以实现多个接口。

   - `Java`中不支持多继承，一个类只能继承一个类，包括抽象类。

4. **构造器**

   - 接口**不能**包含构造器。

   - 抽象类**可以**包含构造器，用于初始化抽象类的子类实例。

5. **访问修饰符**

   - **Java8之前**，接口中的**方法**默认是`public abstract`，**Java8**新增了很多方法，为了**向前兼容**，允许在接口中定义`default`方法和`static`方法，也就是两种可以具体实现的方法，之后因为使用方便，大家在接口里实现了一些**默认逻辑**，所以**Java9开始**，还可以`private`方法**将内部逻辑拆开**。接口中的**变量**默认是`public static final`的。

   - 抽象类中的**抽象方法**默认是`protected`的，**具体方法**的访问修饰符可以是`public`、`protected`或`private`。

详细内容参考：

[【每天一个技术点】抽象类和接口的异同_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV14T4y1e725/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

[Java基础常见面试题总结(中) | JavaGuide](https://javaguide.cn/java/basis/java-basic-questions-02.html#接口和抽象类有什么共同点和区别)

### Case3

#### 题目：Java常见的异常类有哪些

**答案：**

`Java`中所有的异常都是继承自**`Throwable`类**。

常见的异常有以下几类：

- **`RuntimeException`**（运行时异常）：意思是运行时才会抛出的异常，编译器不会处理这类异常，常见的有

  - `NullPointerExcetion`：**空指针异常**，引用一个对象的方法或者访问他的属性时，对象引用为空。
  - `ArrayIndexOutOfBoundsException`：**数组下标越界异常**，尝试访问数组不存在的索引时会抛出。
  - `IllegalArgumentException`：**非法参数异常**，传递给方法的参数不合法时会抛出。
  - `IllegalStateException`：**非法状态异常**，被调用对象状态不正确时会抛出。

  运行时异常一般是**程序的逻辑**有问题，是程序自身的问题而非外部因素。

  其余部分可以认为是**编译时异常**，通常是外部因素导致的，可以用**try-catch**处理，常见的有

- **`IOException`**（输入输出异常）：

  - `FileNotFoundException`：**文件未找到异常**，当尝试打开不存在的文件时抛出。
  - `EOFException`：**文件结束异常**，数据流读取数据时到达文件末尾时抛出。
  - `SocketException`：**套接字异常**，与套接字相关的操作失败时抛出。

- **`SQLException`**（数据库异常）：

  - `SQLSyntaxErrorException`：**SQL语法错误异常**，执行的SQL语句语法错误时抛出。
  - `DataAccessException`：**数据访问异常**，访问数据库出现问题时抛出。

- **`ClassNotFoundException`**：**类未找到异常**，尝试加载不存在的类时抛出。

详细内容参考：

[阿里一面：Java中的异常类有哪些? 说说你常见的异常类 ？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1AN411E7E6/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

## Day24

### Case1

#### 题目：说一说Java面向对象三大特性

**答案：**

Java面向对象编程的三大特性是封装、继承和多态：

1. **封装**：封装是指把一个对象的**状态信息**，也就是属性，**隐藏在对象内部**，不允许外部直接访问对象的内部信息，但是会提供一些**能被外界访问的方法**来操作属性。如果属性不想被外界访问，可以不提供方法给外界访问。如果一个类没有提供给外界访问的方法，那么这个类也就没有意义了。通常使用关键字`private`、`protected`、`public`等来定义访问权限，以实现封装。
2. **继承**：不同类型的对象之间经常有一定的共同点。同时，每一个对象会有各自独一无二的特性。**继承是将已有的类的定义作为基础创建新的类**。通过使用继承，可以快速地创建新类，提高代码的重用性、程序的可维护性。`Java`支持单继承，一个类只能直接继承一个父类。继承主要有以下几个特点：
   - 子类拥有父类所有的属性和方法，不能**选择性**的继承，其中包括私有属性和私有方法，但是**子类无法访问私有类型**，只是拥有。
   - 子类可以**添加自己的属性和方法**来对父类进行拓展。
   - 子类可以用自己的方法**重写**父类的方法。
3. **多态**：多态指一个对象具有多种状态，表现为**父类的引用指向子类的实例**。具体为子类通过方法重载和重写等实现了父类的方法，但是引用类型变量发出的方法调用最终的方法，要在程序运行期间确定，也就是`Java`的**动态绑定机制**。

详细内容参考：

[Java基础常见面试题总结(中) | JavaGuide](https://javaguide.cn/java/basis/java-basic-questions-02.html#面向对象三大特征)

### Case2

#### 题目：说一说你对Java多态的理解

**答案：**

首先说明什么是**多态**，多态就是一个对象具有多种状态，具体表现是把一个子类对象直接赋给**父类引用变量**，在运行时调用该引用变量的方法时，如果该方法是**子类重写或重载**的，会表现出子类方法的行为特征，否则会表现出父类方法的行为特征。也就是说**相同类型的变量**在**调用同一个方法**时呈现出多种不同的行为特征，这就是多态。

多态有两种形式：**编译时多态**（静态多态）和**运行时多态**（动态多态）。

- 编译时多态：指在编译阶段，编译器就能够确定调用哪个方法，这是通过**方法的重载**来实现的。编译器在编译时根据方法的参数数量、类型或顺序来选择调用的方法。
- 运行时多态：在程序运行时，根据**实际对象的类型**来确定调用的方法，这是通过**方法的重写**来实现的。运行时多态主要依赖于对象的**实际类型**，而不是引用类型。

详细内容参考：

[Java基础常见面试题总结(中) | JavaGuide](https://javaguide.cn/java/basis/java-basic-questions-02.html#面向对象三大特征)

### Case3

#### 题目：Java重写和重载的区别

**答案：**

Java中的重载和重写是实现多态的两种不同方式。

- 方法的重载是**编译时多态**，在同一个类中，或者父类和子类之间，多个方法的方法名相同，但是**参数列表不同**，可以是**类型、个数或者顺序不同**，方法返回值和访问修饰符可以不同。也就是说编译时**编译器**通过不同的传参来确定使用的方法。

- 方法的重写是**运行时多态**，是子类对父类中**允许访问的方法**进行重新编写。虚拟机在运行时根据**对象的实际类型**来确定调用哪个方法。有以下几点要求：
  1. 方法名、参数列表必须相同，子类**返回值**类型要比父类的更小或者相等，**抛出异常**的范围小于等于父类，**访问修饰符**范围大于等于父类。
  2. 子类不能重写父类中访问修饰符为**`private/final/static`**的方法，但是被`static`修饰的方法能够被再次声明。
  3. **构造方法**无法被重写。

总结来说，重载关注的是方法的**多样性**，允许同一个类中存在多个同名方法；而重写关注的是方法的**对应性**，允许子类提供自己特定的行为实现。

详细内容参考：

[Java基础常见面试题总结(上) | JavaGuide](https://javaguide.cn/java/basis/java-basic-questions-01.html#重载和重写有什么区别)

## Day25

### Case1

#### 题目：final关键字有什么作用

**答案：**

`final`关键字，意思是最终的、不可修改的，可以修饰变量、方法和类，主要有以下几种特点：

1. **修饰类**：`final`修饰的类不能被继承，final类中的所有成员方法都会被**隐式的指定为final方法**。

2. **修饰方法**：`final`修饰的方法**不能被重写**。

3. **修饰变量**：`final`修饰的变量是常量：

   - 如果修饰**基本数据类型**的变量，其数值一旦在初始化之后便不能更改。

   - 如果修饰**引用类型**的变量，初始化之后不能再指向另一个对象。虽然不能再指向其他对象，但是它指向的对象的**内容是可变的**。

使用`final`的原因有两个：

- 锁定方法，防止继承类修改方法的含义。
- 早期Java实现版本中为了效率，会将final方法转为内嵌调用（**方法调用**替换为方法体的实际代码），但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。现在的Java版本不需要使用final方法进行这些优化了。

详细内容参考：

[final,static,this,super 关键字总结 | JavaGuide](https://javaguide.cn/java/basis/java-keyword-summary.html#final-关键字)

### Case2

#### 题目：==和equals的区别

**答案：**

在Java中，`==`和`equals()`方法都用来比较对象，但它们在语义和使用上有一定的差别：

1. `==`运算符：对于**基本数据类型**，`==`比较的是**值**是否相等；对于**引用类型**，`==`比较的是两个引用是否指向内同一个**内存地址**，即它们是否是同一个对象。
2. `equals()`是定义在`Object`类中的一个方法，而`Object`类是所有类的直接或间接父类，所以所有类都有`equals()`方法。使用时有两种情况：
   - 类**没有重写**`equals()`方法时，用`equals()` 方法比较该类的两个对象用的是`Object`类中的`equals()`，等价于使用`==`比较。
   - 类**重写**了`equals`方法时，一般都会重写`equals()`方法来比较两个对象中的**属性**是否相等；若它们的属性相等，则返回true，也就是认为这两个对象相等。
3. 比如`String`类，现在创建两个`String`类对象，第一个对象初始化时，会将字符串放入**常量池**中，如果第二个对象内容和第一个一样，那么第二个对象指向的**内存地址**会和第一个对象**一致**，这时不管用`==`还是`equals()`，返回的都是true。
4. 需要注意的是，两个相等对象的**hashcode**也应该是相同的，所以在重写`equals()`方法时，应同时重写`hashCode()`方法，以保持`equals()`和`hashCode()`的一致性。

详细内容参考：

[Java基础常见面试题总结(中) | JavaGuide](https://javaguide.cn/java/basis/java-basic-questions-02.html#和-equals-的区别)

## Day26

### Case1

#### 题目：Java的集合类有哪些，哪些是线程安全的，哪些是线程不安全的？

**答案：**

![java-collection-hierarchy](./pictures/java-collection-hierarchy.png)

`Java`集合类的诞生是为了弥补数组的缺陷，数组是**定长而且类型统一**的，而集合类的**大小可以动态改变**，可以**存储不同类型的对象**。

1. `Java`的集合类，主要是由两大接口派生而来：一个是`Collection`接口，主要用于**存放单一元素**；另一个是`Map`接口，主要用于**存放键值对**。对于`Collection`接口，下面又有三个主要的子接口：`List`、`Set`、`Queue`。

   - `List`接口：有序集合，存储的元素是**有序的、可重复的**。常见的实现类有`ArrayList`、`Vector`、`LinkedList`等。其中`ArrayList`和`Vector`的底层实现都是**动态`Object[]`数组**，`LinkedList`的底层实现是**双向链表**。
   - `Set`接口 ：集合中的元素**不可重复**。常见的实现类有`HashSet`、`LinkedHashSet`、`TreeSet`等。
     - `HashSet`底层采用`HashMap`来保存元素，数据**存入和取出的顺序不一致**，但是取出的遍历顺序是固定的。
     - `LinkedHashSet`是`HashSet`的子类，底层是通过`LinkedHashMap`来实现的，利用**双向链表**保证数据**有序**。
     - `TreeSet`底层是红黑树，数据是**按照一定规则排序**的。
   - `Queue`接口：存储的元素**有序、可重复**。常见的实现类有`LinkedList`、`PriorityQueue`、`ArrayDeQue`等。
     - `LinkedList`不仅实现了`List`接口，也实现了`DeQue`接口。
     - `PriorityQueue`则用`Object[]`数组实现了小顶堆，可以自定义`Comparator`来实现大顶堆。
     - `ArrayDeQue`是**可扩容的动态双向数组**。

   - `Map`接口：是存储**键值对**的集合。常见的实现类有`HashMap`、`LinkedHashMap`、`TreeMap`等。
     - JDK1.8之前`HashMap`由数组+链表组成的，**数组**是**主体**，**链表**主要用于**解决哈希冲突**。JDK1.8加入了红黑树，当链表长度大于阈值，默认为 8，但是数组的长度小于64，会选择数组扩容；而链表长度大于阈值，并且数组长度大于等于64，将链表转化为红黑树。
     - `LinkedHashMap`继承了`HashMap`，底层也是由**数组和链表或红黑树**组成，在此基础上增加了一条**双向链表**，使`LinkedHashMap`可以记录键值对的**插入顺序**。
     - `TreeMap`底层则是用**红黑树**实现。

2. 对于上述的实现类而言，**基本都是线程不安全的**，这里的线程不安全指的是实现类对数据进行操作时并不是原子操作，所以在并发操作时可能会导致数据不一致等问题。

3. 线程安全的集合类主要有以下几种

   - `List`接口的**`Vector`**：`Vector`实现的方法与`ArrayList`类似，但是它的方法都是同步的，因此是线程安全的。然而，`Vector`体量更大不够灵活，通常建议使用`ArrayList`。

   - `Map`接口的**`HashTable`**：实现的方法与`HashMap`类似，但它是线程安全的。但是也更加推荐使用`HashMap`。
   - `java.util.concurrent`：除了上述两种，`java.util.concurrent`包下提供了很多实现了线程安全的类：
     - `ConcurrentHashMap`：通过**原子操作**和**局部加锁**实现了线程安全，相比`HashTable`直接**同步整个方法**更加高效。

   - `java.util.Collections`：`java.util.Collections`包下也有很多实现了线程安全的类：`synchronizedList`、`synchronizedSet`、`synchronizedMap`（用迭代器遍历时要手动同步）。

详细内容参考：

[Java集合常见面试题总结(上) | JavaGuide](https://javaguide.cn/java/collection/java-collection-questions-01.html#java-集合概览)

### Case2

#### 题目：ArrayList和Array有什么区别？ArrayList和LinkedList的区别是什么？

**答案：**

1. `ArrayList` vs `Array`：

   - **底层数据结构**：`ArrayList`内部基于动态数组实现，创建时不用指定大小，`Array`是静态数组，创建时要指定大小，前者使用起来更加灵活。
   - **扩容**：`ArrayList`会动态地扩容或缩容，而`Array`被创建之后就不能改变它的长度了。
   - **泛型**：`ArrayList`允许使用泛型来确保类型安全，`Array`则不可以。
   - **存储内容**：`ArrayList`中只能存储对象。对于基本类型数据，需要使用其**对应的包装类**（如 Integer、Double 等）。`Array`可以直接存储基本类型数据，也可以存储对象。
   - **API**：`ArrayList`提供了丰富的 API ，比如 `add()`、`remove()`等。`Array`只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。

   - **随机访问**：在随机访问时，`Array`由于其**连续内存**存储，性能通常优于`ArrayList`。

2. `ArrayList` vs `LinkedList`：

   - **是否保证线程安全**：`ArrayList`和`LinkedList`都是不同步的，也就是不保证线程安全，但可以使用`synchronizedList`进行包装确保线程安全（`List<Object> syncArrayList = Collections.synchronizedList(new ArrayList<>());`）；
   - **底层数据结构**：`ArrayList`底层使用的是**`Object[]`数组**；`LinkedList`底层使用的是**双向链表**。
   - **插入和删除是否受元素位置的影响**：
     - `ArrayList` 采用**数组**存储，所以插入和删除元素的**时间复杂度受元素位置影响**。 比如：将元素追加到此列表的末尾时，时间复杂度就是`O(1)`。但是如果要在指定位置`i`插入和删除元素的话，需要挪动数组，时间复杂度就为`O(n)`。
     - `LinkedList`采用**链表**存储，所以在头尾插入或者删除元素的时间复杂度为`O(1)`，如果是要在指定位置`i`插入和删除元素，需要先遍历部分链表，所以时间复杂度为`O(n)`。
   - **是否支持快速随机访问**：`LinkedList`不支持高效的随机元素访问，而`ArrayList`底层是数组，所以支持（实现了`RandomAccess`接口） 。
   - **内存空间占用**：`ArrayList`的空间浪费在于数组会预留一定的容量，而`LinkedList`的空间浪费在每一个元素消耗更大，要比`ArrayList`多存放指针。
   - **使用场景**：频繁的随机访问多，则选择`ArrayList`，插入和删除操作多，则选择 `LinkedList`，因为`ArrayList`的扩容会带来额外成本。

详细内容参考：

[常见集合篇-08-ArrayList和LinkedList的区别是什么？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1yT411H7YK/?p=76&share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

[Java集合常见面试题总结(上) | JavaGuide](https://javaguide.cn/java/collection/java-collection-questions-01.html#arraylist-和-array-数组-的区别)

[Java集合常见面试题总结(上) | JavaGuide](https://javaguide.cn/java/collection/java-collection-questions-01.html#arraylist-与-linkedlist-区别)

### Case3

#### 题目：ArrayList扩容机制

**答案：**

1. `ArrayList`扩容的本质，是计算出扩容后数组的`size`，然后创建一个新的数组，将原有数组内容复制过去。
2. 当我们使用无参构造器创建`ArrayList`时，实际上初始化赋值的是一个空数据，当对数组添加元素时才会分配容量，将容量扩大为10。如果使用有参构造器，则初始容量就是指定的容量。
3. 当`ArrayList`中的元素数量达到当前容量时，`ArrayList`会自动增加其容量。`ArrayList`扩容的计算是`grow()`方法中进行，`grow()`方法先尝试将数组扩大为原数组的1.5倍。计算方式是旧容量右移一位再加上旧容量。
4. 若新的容量满足需求，会调用一个`Arrays.copyof()`方法，将所有的元素从旧数组复制到新数组中，这个方法是真正实现扩容的步骤。如果扩容后的新容量还是不满足需求，那新容量大小为当前所需的容量加1。
5. 所以如果再初始化时需要加入大量数据，最好使用有参构造器指定容量大小，避免扩容带来的额外成本。

详细内容参考：

[ArrayList 源码分析 | JavaGuide](https://javaguide.cn/java/collection/arraylist-source-code.html#arraylist-扩容机制分析)

## Day27

### Case1

#### 题目：HashMap的底层实现是什么？

**答案：**

1. **JDK1.7及之前**：`HashMap`由数组和链表组成，发生哈希冲突时，`HashMap`采用链地址法解决冲突，多个元素会以链表的形式存储在同一个数组位置。这时`HashMap`的

   - **读复杂度**：
     - 在**最佳情况**下：是O(1)
     - 在**最坏情况**下：发生哈希冲突时为O(n)，n取决于链表长度。
   - **写复杂度**：
     - 在**理想情况**下：与读操作类似，也是O(1)。
     - 发生**哈希冲突**时：需要在链表尾部添加新元素，时间复杂度为O(n)。

2. **JDK1.8时**：`HashMap`引入了**红黑树**，当链表长度超过一定阈值（TREEIFY_THRESHOLD，默认为8）时，链表会转换成红黑树，以提高搜索效率。这时有两个问题：

   - 为什么要引入红黑树，而不是其他树？
     - 红黑树不追求绝对的平衡，插入或删除节点时，允许有一定的局部不平衡，减少了很多性能开销。
     - 红黑树作为**自平衡的二叉搜索树**，插入和删除操作的时间复杂度都是O(log n)。
   - 链表树化的默认阈值为什么是 **8**，而树链表化的阈值为 **6**：根据泊松分布，在负载因子默认为0.75的时候，单个hash槽内元素个数为8的概率小于百万分之一，所以将 7 作为一个分水岭， 大于等于 8 的时候才转化成红黑树，小于等于 6 的时候转化为链表。

   引入红黑树后

   - **读复杂度**：
     - 在**最佳情况**下：是O(1)
     - 在**最坏情况**下：时间复杂度降为O(log n)。
   - **写复杂度**：
     - 在**理想情况**下：也是O(1)。
     - 处理**哈希冲突**时：如果还是链表状态或者需要正在转换为红黑树时时间复杂度为O(n)，如果已经转换为红黑树则为O(log n)。

详细内容参考：

[厉害了！把 HashMap 剖析的只剩渣了！](https://mp.weixin.qq.com/s/gJXv3x-yGkG8IT97hZvWvQ)

### Case2

#### 题目：解决Hash冲突的方法有哪些？HashMap是如何解决Hash冲突的？

**答案：**

解决哈希冲突的方法有很多：

1. **再哈希法**：发生哈希冲突时，将当前的位置再次哈希，直到不发生冲突为止。这种方法的**计算开销比较大**。
2. **公共溢出表法**：建立公共表来存放所有冲突的关键字，在查找时会先查找基本表的位置，如果未找到则进入公共表进行**顺序查找**。
3. **开放寻址法**：当发生哈希冲突时，根据某种探测算法在哈希表中寻找下一个空闲位置来存储元素。
4. **链地址法**：在数组的每个位置维护一个链表。当发生冲突时，新的元素会被添加到链表的尾部。

`Java`中的`HashMap`使用**链地址法**解决hash冲突，并且在JDK1.8之后引入了红黑树来优化。

详细内容参考：

[厉害了！把 HashMap 剖析的只剩渣了！](https://mp.weixin.qq.com/s/gJXv3x-yGkG8IT97hZvWvQ)

### Case3

#### 题目：HashMap的put方法流程

**答案：**

put方法的流程如下：

1. 判断**键值对数组**是否为空或为null，如果是的话执行resize()进行扩容。`HashMap`在原数组长度为0时，扩容的默认长度为16，负载因子为0.75。

2. 根据**键值key计算hash值**得到插入的**数组索引 i**，具体的计算流程为：

   - 对key对象的hashcode进行**扰动**。也就是先通过hashCode方法得到key对象的**hashcode**，然后将hashcode的低16位与高16位进行异或，高16位保持不变。

   - 对hashcode取模获得数组下标。HashMap在JDK1.8中不是简单的用`%`运算符进行取模。首先`HashMap`会控制数组的长度为2的整数次幂，有两种情况：

     - 初始化时指定的初始长度为16，而扩容是将容量扩大两倍，所以这时长度都是2的整数次幂。
     - 如果初始化指定了一个非2的整数次幂长度，那么在扩容时会将它扩容为大于旧容量的最小2的整数次幂。

     确保了数组长度为2的整数次幂之后，就可以使用**位与运算**来求余，将hashcode与数组长度-1进行位与运算，效率会高很多。

   得到数组索引 i 之后，如果这个位置为空，则直接添加节点，转向扩容步骤；如果这个位置不为空，则需要继续判断。

3. 会使用hashCode方法和equals方法来判断要插入的元素和位置上的元素是否相同，相同则直接覆盖value。

4. 如果不相同，则需要判断当前位置是一个链表还是红黑树，如果是红黑树，则直接插入。

5. 如果是链表，并且链表长度大于等于8，数组长度大于等于64，则把链表转化为红黑树，在树中插入元素；如果链表长度达到8，但是数组长度小于64，则扩容数组，然后在链表中插入元素；如果链表长度没有达到8，那么直接在链表中插入元素。

6. 插入成功后，判断实际存在的键值对数量是否超过了容量上限，这里的**上限是负载因子乘以数组长度获得**，如果超过，进行扩容。

详细内容参考：

[厉害了！把 HashMap 剖析的只剩渣了！](https://mp.weixin.qq.com/s/gJXv3x-yGkG8IT97hZvWvQ)

### Case4

#### 题目：HashMap的扩容机制

**答案：**

`HashMap`中扩容的时机由**装载因子**来控制，`HashMap`中数组的容量上限是数组长度乘以装载因子，当数组中节点数达到容量上限时，会进行扩容。

1. JDK1.7扩容机制

   - 创建新数组，遍历老数组中每个位置的链表中的每个元素；
   - 获取每个元素中key的hashcode，然后基于**新数组长度**，计算出每个元素在新数组中的下标；
   - 将元素添加到新数组中之后，把新数组赋值给`HashMap`对象的table属性。

   这种机制有两个问题：

   - 每个节点都要进行一次**求余**计算
   - `HashMap`并不是线程安全的，插入用的是头插入法，多线程环境下可能形成**链表环**。

2. JDK1.8扩容机制：和JDK1.7扩容机制的主要区别在于，JDK1.8中`HashMap`会将数组长度控制为**2的整数次幂**，而数组扩容也是旧容量乘以2，所以扩容后的位置，要么是**原位置**，要么是**原位置加原数组长度**。而且只需要查看hashcode中比原来高一位的值是0还是1，0在原位置，1在原位置加数组长度。
   这样就解决了需要重新求余计算的问题，至于多线程的冲突，则可以用`synchronizeMap()`或者`ConcurrentHashMap`来解决。

详细内容参考：

[厉害了！把 HashMap 剖析的只剩渣了！](https://mp.weixin.qq.com/s/gJXv3x-yGkG8IT97hZvWvQ)

## Day29

### Case1

#### 题目：HashMap为什么是线程不安全的？如何实现线程安全

**答案：**

（1）为什么是线程不安全的

主要原因是在于`HashMap`的操作**不是原子操作**，即在多个线程并发操作时，可能会导致数据不一致性或抛出异常。主要容易出现以下几个问题：

1. **扩容死循环**：在JDK1.7中，`HashMap`使用**头插法**插入元素，所以多个线程同时扩容时，可能导致**环形链表**的形成；所以在JDK1.8中，采用了**尾插法**来避免生成环形链表。
2. **元素丢失**：多个线程同时执行put方法时，如果操作了同一个元素，可能导致前一个value被后一个覆盖，或者抛出`ConcurrentModificationException`异常。
3. **get为null**：当一个线程执行put操作并导致扩容的同时，如果有另一个线程在执行get操作，可能会因为`HashMap`结构的改变导致get没有查找到元素。

（2）如何实现线程安全

为了实现线程安全的`HashMap`，有以下几种方式：

1. 使用**`ConcurrentHashMap`**：他是专门为**多线程环境**设计的哈希表，使用**分段锁**机制，提供了高效的并发性能。
2. 使用**`synchronizedMap()`**方法：可以通过`Collections.synchronizedMap()`方法创建一个线程安全的`HashMap`，该方法返回一个同步的`Map`包装器，使得所有对`Map`的操作都是同步的。
3. 使用**线程局部变量**：为每个线程维护一个独立的`HashMap`实例，也就是每个`HashMap`操作都是单线程的，避免了多线程的问题。
4. 使用**锁**机制：可以在自定义的`HashMap`操作中使用显式的锁（例如 `ReentrantLock`）来保证线程安全。

详细内容参考：

[字节一面：HashMap 是线程安全的吗 ？在多线程环境下会有什么问题 ？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1tC4y1n7pN/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

### Case2

#### 题目：concurrentHashMap如何保证线程安全

**答案：**

1. 在**JDK1.7**中：`ConcurrentHashMap`底层结构为数组加链表，数组分为两类，**不可扩容**的大数组`Segment`和小数组`HashEntry`，`Segment`数组继承了`ReentrantLock`（一种重入锁），负责实现线程安全，`HashEntry`数组用于存储键值对数据。
   具体实现方式是`Segment`每个位置都包含一个`HashEntry`数组，`HashEntry`每个位置是一个链表结构的元素。要修改某一个`HashEntry`数组时，必须先获得对应的`Segment`的锁。也就是说同一个`Segment`不能并发写入，不同的`Segment`写入可以并发执行。`Segment`数组默认大小为16，也就是默认可以支持16个线程并发写。
2. 在**JDK1.8**中：`ConcurrentHashMap`数据结构和JDK1.8中的`HashMap`类似。取消了`Segment`分段锁，采用了`Node + CAS(compare and swap，一种乐观锁) + synchronized`来保证线程安全，锁粒度更细，`synchronized`只锁定当前链表或红黑树的首节点，所以只要没有哈希冲突，就不会影响其他Node的读写。所以最大并发数是Node数组的大小。

详细内容参考：

[Java集合常见面试题总结(下) | JavaGuide](https://javaguide.cn/java/collection/java-collection-questions-02.html#concurrenthashmap-线程安全的具体实现方式-底层具体实现)

### Case3

#### 题目：HashMap和ConcurrentHashMap的区别

**答案：**

1. **线程安全性**：
   - `HashMap`不是线程安全的。在多线程环境中，如果同时进行读写操作，可能会导致数据不一致或抛出异常。
   - `ConcurrentHashMap`是线程安全的，JDK1.7使用了分段锁（`Segment Locking`）的机制，JDK1.8使用了`CAS + synchronized`，提高了并发性能。
2. **同步机制**：
   - `HashMap`本身没有实现同步机制，需要在外部进行同步，例如使用`synchronizedMap()`方法进行包装。
   - `ConcurrentHashMap`JDK1.7和1.8中使用了不同的同步机制，因此在多线程环境中具有更好的性能。
3. **迭代遍历的区别**：
   - 在`HashMap`中，如果在迭代过程中有其他线程在修改数组，可能抛出`ConcurrentModificationException`异常。
   - `ConcurrentHashMap`允许在迭代时进行并发的插入和删除操作。但是**JDK1.7版本不保证迭代器的顺序**，因为不同的段可能会以不同的顺序完成操作。
4. **初始化容量和负载因子：**
   - `HashMap`可以通过构造方法设置初始容量和负载因子。
   - `ConcurrentHashMap`在JDK1.8中引入了有参构造方法（`ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)`），允许设置初始容量、负载因子和并发级别。
5. **性能：**
   - 在低并发情况下，`HashMap`的性能可能会比`ConcurrentHashMap`稍好，因为`ConcurrentHashMap`需要维护额外的并发控制。
   - 在高并发情况下，`ConcurrentHashMap`的性能通常更好，因为它能够更高效地支持并发访问。

总的来说，如果需要在多线程环境中使用哈希表，而且需要高性能的并发访问，通常会选择使用`ConcurrentHashMap`。如果在单线程环境中使用，或者选择手动同步，通常会选择`HashMap`。





