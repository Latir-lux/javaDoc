# 八股训练营

## Day22

### Case1

#### 题目：介绍一下Redis缓存雪崩和缓存穿透，如何解决这些问题？

**答案：**

目前大多数数据库都是由**Redis和MySQL协同合作**的，Redis负责**缓存**，MySQL负责**存储**。请求数据的流程是先访问Redis，如果Redis有数据直接返回，没有的话就需要查询数据库，然后数据库**返回结果并把数据同步**到Redis。但是MySQL是基于磁盘的，承担不了大量请求。所以**缓存异常**时，大量请求**直接访问数据库**就会出问题，主要情况有三种：

1. **缓存雪崩**：为了保证**缓存**中数据和**数据库**中数据的**一致性**，通常会给Redis中的数据设置过期时间，数据过期之后，请求就会**直接访问数据库**。那么当大量缓存数据在同一时间过期或者Redis故障宕机时，数据库就会压力骤增，系统崩溃，这就是缓存雪崩。
   当大量数据同时过期导致雪崩时，处理方式有以下几种：

   - **设置不同过期时间**：对缓存中数据设置过期时间时，可以给过期时间加上一个**随机数**。
   - **设置互斥锁**：如果请求的数据不在Redis中，在请求访问数据库时需要**获取互斥锁**，确保同一时间只有一个请求访问，最好给互斥锁设置**超时时间**，防止出现问题阻塞整个系统。
   - **后台更新缓存**：可以设置缓存**“永久有效”**，也就是将更新缓存的工作交给后台线程，后台线程可以**不断检测缓存是否有效**，也可以在**业务线程**发现缓存失效后通过**消息队列通知后台线程**。

   因为Redis故障宕机而雪崩的处理方式有以下几种：

   - **服务熔断或者请求限流机制**：可以启动服务熔断机制，**暂停对缓存的访问**，直接**返回错误**；或者请求限流，只将**少部分请求**发送到数据库，其余请求直接**拒绝**。
   - **构建Redis缓存高可靠集群**：服务熔断和请求限流是雪崩发生后的方案，发生前可以用**主从节点**的方式构建集群，**主节点宕机后切换到从节点**。

2. **缓存击穿**：业务中通常会有几个数据被**频繁的访问**，这些数据就是**热点数据**。如果某个**热点数据过期**了，大量请求会直接访问数据库，导致数据库被**高并发请求冲垮**，这就是缓存击穿。
   缓存击穿和缓存雪崩很相似，所以他们处理方式也很类似：

   - **互斥锁方案**：同一时间只允许一个业务线程更新缓存。
   - **后台更新缓存**：用**后台线程**异步更新热点数据，或者在数据快过期之前，通知后台线程更新缓存。

3. **缓存穿透**：如果用户要访问的数据，**不在缓存中**，**也不在数据库中**，那么数据库没办法构建缓存，大量这样的请求到来时，数据库压力骤增，就是缓存穿透。
   常见的原因有两种，**业务误操作**，删除了缓存和数据库中的数据；或者是**黑客恶意攻击**，故意读取不存在的数据。常见应对方案有三种：

   - **限制非法请求**：在API入口处判断**请求参数是否合理**，如果包含非法值直接**返回错误**。
   - **缓存空值或者默认值**：针对查询的数据**缓存一个空值或默认值**，后续的请求会直接从缓存中读取空值或默认值。
   - **布隆过滤器**：布隆过滤器由**位图数组**和**N个哈希函数**组成，往数据库写入数据时，过滤器使用N个哈希函数计算出N个哈希值，找到位图数组中对应的**N个位置将他们置1**，有请求访问数据库时，查询对应数据的N个位置，**全为1则访问数据库**，否则不访问。布隆过滤器认为存在，数据不一定存在，但是**过滤器认为不存在，则数据一定不存在**。

详细内容参考：

[什么是Redis缓存雪崩、穿透、击穿，十分钟给你讲的明明白白_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1f5411b7ux/?share_source=copy_web&vd_source=db4b8256b37979f4e7f296b129aaaf87)

[什么是缓存雪崩、击穿、穿透？ | 小林coding](https://xiaolincoding.com/redis/cluster/cache_problem.html#缓存雪崩)

### Case2

#### 题目：如何保证数据库和缓存的一致性

**答案：**

保证数据库和缓存的一致性的第一个问题是，缓存是**更新还是删除**。

如果**更新缓存**，由于缓存不会适合加锁，那么无论是先更新数据库还是先更新缓存，有**多个请求并发更新同一条**数据时，都容易出现数据不一致现象，所以一般不更新缓存。

**Cache Aside**：如果选择**删除缓存**，那么就是**Cache Aside策略（旁路缓存策略）**，这时**多条更新同一个数据**的请求相互之间没有威胁，因为缓存最终都会被删除，有冲突的是**写策略和读策略**。读策略在**缓存未命中**时会从数据库把数据写回缓存，这时如果我们**先删除缓存再更新数据库**，可能会导致读策略把旧数据写入缓存，因为**数据库写入比缓存写入要慢很多**，所以反过来**先更新数据库，再删除缓存**，出问题的概率会小很多。

但是Cache Aside还会出现别的问题，常见的就是最后**删除缓存的操作失败了**，这样子只能等**下次更新**或者**缓存过期**才会恢复正常。这个问题的解决方案有：

- **消息队列**：将要删除的缓存数据加入到消息队列，如果删除缓存失败了，会从消息队列中读取数据再次删除，这就是**重试机制**，如果成功了就把数据从消息队列中删除。
- **订阅binlog**：阿里巴巴开源的**Canal中间件**的作用是模拟出一个从节点，向主节点发送dump请求，接收binlog后转化为**结构化数据**，然后根据log删除缓存，**删除成功后发送ACK确认删除**。

除了Cache Aside还有两种保证一致性的方法。

**Read/Write Through**

- **原理**：原理是把更新数据库（Repository）的操作由**缓存代理**。
- **Read Through**：就是在**查询操作**中更新缓存，Cache Aside策略是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对调用方是透明的。
- **Write Through**：在数据更新的时候，如果没有命中缓存，就只更新数据库。如果命中了缓存，则更新缓存，然后再由缓存服务更新数据库。

**Write Behind**

- **原理**：在更新数据的时候，只更新缓存，不更新数据库，而缓存会异步地批量更新数据库。这个设计的好处就是让数据的I/O操作非常快，带来的问题是，数据不是强一致性的，而且可能会丢失。

详细内容参考：

[帮面试官写代码，我被录用了，数据库与缓存的数据一致性问题分析_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1dU4y1f7Pa/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

[数据库和缓存如何保证一致性？ | 小林coding](https://xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#数据库和缓存如何保证一致性)















