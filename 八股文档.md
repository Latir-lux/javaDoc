# 八股训练营

整理顺序为代码随想录八股训练营题目顺序

## Day1

### Case1

------

#### 题目：介绍一下TCP/IP模型和OSI模型的区别

**答案：**

**1.OSI模型**

OSI模型是国际标准化组织（ISO）制定的一个用于计算机或者通信系统之间互联的标准体系，把计算机网络通信划分为七个不同的层级，每个层级负责特定的功能。每个层级都构建在其下方的层级之上，并且为其上方的层级提供服务。
七层从下到上分别为物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。

**2.OSI模型和TCP/IP模型关系**

OSI模型发布时间比TCP/IP模型早，并且理论上OSI模型更全面，但是实际上TCP/IP模型更加实用，所以目前大多数开发场景都基于TCP/IP模型。

**3.TCP/IP模型**

TCP/IP模型分为四层，下面从上到下进行介绍。

**应用层：**
最上层是应用层，这一层与OSI模型的应用层、表示层和会话层相似，提供直接与用户程序交互的接口，比如电子邮件（SMTP）、网页浏览（HTTP）、文件传输（FTP）等。

各种计算机系统的应用软件都是在应用层实现的，两个不同设备的应用需要通信时，应用层就把数据传给下一层，并不关心数据是如何传输的。

（回答时候去掉：应用层工作在操作系统的用户态，传输层及一下工作在内核态。）

**传输层：**
应用层下面是传输层，该层对应OSI模型的传输层，负责在端到端的数据传输时提供传输服务。

主要有两个传输协议，TCP和UDP。TCP提供可靠的数据传输，确保了数据的正确性和完整性。UDP则是无连接的、不可靠的，实时性更好，效率更高，适用于不要求可靠性的传输，比如实时音频和视频流。

**网络层：**
传输层下面是网络层，该层对应OSI模型的网络层。传输层听起来像是负责把数据从一个设备传输到另一个设备，事实上这部分是由网络层负责的，传输层的功能是服务好应用层，也就是打包和接收数据。

网络层的常用协议是IP协议，主要作用是寻址和路由，用IP地址标识源主机和目标主机，用路由来选择最佳路径传输数据。

**网络接口层：**
网络层下面是网络接口层，该层对应OSI模型的数据链路层和物理层。

网络层只负责网络层级的传输，网络接口层则负责这个层级之下物理传输媒介的传输，比如以太网、WiFi等。这个层级使用MAC地址标识网络上的设备，所以网络接口层包含对MAC地址的管理，也有错误检测和纠错功能。

详细内容参考：[2.1 TCP/IP 网络模型有哪几层？ | 小林coding](https://xiaolincoding.com/network/1_base/tcp_ip_model.html#应用层)

### Case2

------

#### 题目：从输入URL到页面展示到底发生了什么？

**答案：**

**第一步**是浏览器对URL进行解析，生成发送给Web服务器的请求信息。

**第二步**是查询得到服务器域名对应的IP地址。查询的顺序是浏览器缓存，操作系统缓存，host文件，路由器缓存，本地DNS服务器。这部分都是客户端在访问，之后如果本地DNS服务器没有IP信息，本地DNS服务器会依次访问根DNS服务器，顶级DNS服务器，权威DNS服务器，最后从权威DNS服务器得到IP地址返回给客户端。

**第三步**，有了IP地址之后，浏览器与服务器IP三次握手建立TCP连接。

**第四步**，将第一步得到的http报文依次包上TCP头部、IP头部、MAC头部，其中还会包含和该域名相关的Cookie等数据，然后浏览器就会将请求发出。如果是HTTPS的话，还要涉及到HTTPS的加密解密流程。

**第五步**，请求发出之后，会依次经过网卡、交换机、路由器等设备，最终到达目标IP。这个过程中的MAC头部会不断的变化，但是源IP和目的IP一直不会改变。

**第六步**，服务器接收到请求，一层层解析头部，同时判断这个请求是否是发给自己的，如果是发给自己的，根据请求生成响应数据。

**第七步**，TCP四次挥手断开连接，浏览器和服务器IP断开TCP连接。

**第八步**，浏览器解析响应数据并渲染页面。

下面这部分是拓展，考官问了说。

- 浏览器解析响应头。若响应头状态码为301、302，会重定向到新地址；若响应数据类型是字节流类型，一般会将请求提交给下载管理器；若是HTML类型，会进入下一部渲染流程。
- 浏览器解析HTML文件，创建DOM树，解析CSS进行样式计算，然后将CSS和DOM合并，构建渲染树；最后布局和绘制渲染树，完成页面展示。

详细内容参考：[2.2 键入网址到网页显示，期间发生了什么？ | 小林coding](https://xiaolincoding.com/network/1_base/what_happen_url.html)

## Day2

### Case1

#### 题目：HTTP请求报文和响应报文是怎样的，有哪些常见的字段？

**答案**：

HTTP报文分为请求报文和响应报文

**请求报文**主要由**请求行、请求头部、空行和请求数据**四个部分组成。
**请求行**由**请求方法、URI和HTTP协议版本**三个字段组成，每个字段之间用空格隔开，最后一个字段后面跟回车符和换行符。
**请求方法**有以下几种：HTTP1.0定义了GET、POST和HEAD三种方法，HTTP1.1新增了OPTIONS、PUT、PATCH、DELETE、TRACE和CONNECT六种方法。
**请求头部**字段常见的有：

- Accept：客户端能够处理的媒体类型。
- Accept-Encoding：客户端能够解码的内容编码方式，比如gzip。
- Accept-Language：客户端所希望的语言种类，在服务器能够提供一种以上的语言版本时需要。
- Authorization：用于认证的凭证信息，比如token数据。
- Content-Type：请求体的媒体类型。
- Content-Length：请求体的长度。
- Host：客户端要访问的服务器域名。
- User-Agent：包含发出请求的用户信息，客户端类型。
- Cookie：存储在客户端的cookie数据。
- Connection：管理连接的选项，比如keep-alive。
- If-None-Match：资源的ETag值，用于缓存控制。

请求头部之后是**空行**，用于告知服务器请求头部到此为止。
在空行之后是**请求数据**，如果方法字段是GET，那么这一项为空，如果是方法字段是POST，请求数据是要提交的数据，比如我要登录服务器，这部分就会放置username和password。

**响应报文**是服务器向客户端返回的数据格式，用于传达服务器对客户端请求的处理结果和相关数据。主要由**状态行、响应头部、空行和响应正文**四个部分组成。
**状态行**由**协议版本、状态码和原因短语**组成，每个字段由空格隔开，其中原因短语是可选的。最后也跟回车符和换行符。
**响应头部**字段常见的有：

- Allow：服务器支持哪些请求方法。
- Content-Encoding：文档的编码方法。
- Content-Length：响应正文的长度。
- Content-Type：响应正文的媒体类型。
- Date：当前的GMT时间。
- Location：该字段会配合302状态码使用，重定向到一个新的URI地址。
- Server：指定服务器的信息。
- Set-Cookie：设置与页面关联的Cookie。
- Last-Modified：资源最后被修改的日期和时间。
- Expires：响应的过期时间，之后的内容被认为是过时的。
- ETag：响应体的实体标签，用于缓存和条件请求。
- Access-Control-Allow-Origin: 跨源资源共享（CORS）策略，指示哪些域可以访问资源。

响应头部之后也是一个**空行**，用于告知响应头部结束了。

最后是**响应正文**，是服务端实际传输的数据，可以是文本、HTML页面、图片、视频等，也可以是空。

详细内容参考：

[训练营](https://kamacoder.com/training-camp/32)

[3.2.5 HTTP_1.1请求报文格式_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1gg4y1P7Yt/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

[3.2.6 HTTP_1.1响应报文格式_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Sm4y1J7dr/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

### Case2

#### 题目：HTTP有哪些请求方式？

**答案：**

| 序号 | 方法    | 描述                                                         |
| ---- | ------- | ------------------------------------------------------------ |
| 1    | GET     | 请求从服务器获取一个资源                                     |
| 2    | POST    | 向指定资源提交数据进行处理请求，比如提交表单                 |
| 3    | HEAD    | 请求一个与GET请求相同的响应，但是没有响应体，用于检查资源的元数据 |
| 4    | PUT     | 发送数据以更新现有资源，如果资源不存在则创建新的资源         |
| 5    | DELETE  | 删除指定的资源                                               |
| 6    | PATCH   | 对资源进行部分修改，PUT是整个替换，PATCH是修改部分           |
| 7    | OPTIONS | 查询服务器支持的请求方法                                     |
| 8    | TRACE   | 对到目标资源的路径进行环回测试，主要用于诊断                 |
| 9    | CONNECT | 建立一个到服务器的隧道，常用于HTTPS连接                      |

详细内容参考：

[HTTP 请求方法 - HTTP | MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods)

[HTTP 请求方法 | 菜鸟教程](https://www.runoob.com/http/http-methods.html)

### Case3

#### 题目：GET请求和POST请求的区别

**答案：**

按照RFC规范分析，两者主要有以下区别：

- 语义：GET是从服务器获取指定资源，POST是根据请求负荷对指定的资源作出处理。
- 参数：GET参数一般写在URL中，并且只支持ASCII字符，浏览器对URL的长度会有限制。POST携带的数据一般写在报文body中，支持任意格式，理论上没有长度限制。
- 安全性：针对服务器的安全来说，GET属于“只读”类型，不会修改服务器数据，是安全的，POST会修改数据，对服务器不安全。针对数据泄露的安全来说，GET的数据直接暴露在URL中，而POST的数据在HTTP协议下可以通过抓包得到，两者都不太安全。
- 幂等：GET因为是“只读”的，所以他是幂等的，而POST每次提交都可能修改数据或者创建资源，不是幂等的。
- 缓存：GET请求可以被缓存，而POST默认不会被缓存。

详细内容参考：

[3.1 HTTP 常见面试题 | 小林coding](https://xiaolincoding.com/network/2_http/http_interview.html#get-与-post)

[GET - HTTP | MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET)

[POST - HTTP | MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST)

## Day3

### Case1

#### 题目：HTTP中常见的状态码有哪些？

**答案：**

1xx类状态码是信息响应，属于**提示信息**，是协议处理中的一种中间状态，实际用到的比较少。

2xx类状态码是成功响应，表示服务器**成功**处理了客户端的请求，常用的如下：

- [200 OK] 是最常见的成功状态码，表示一切正常。
- [201 Created] 表示请求成功，并且因为请求创建了一个新的资源，通常是对POST或者PUT请求的响应。
- [204 No Content] 与200基本相同，但响应头没有body数据。
- [206 Partial Content] 应用于HTTP分块下载或断点续传，响应返回的body数据是资源的一部分。

3xx类状态码是重定向消息，表示客户端请求的资源发生了变动，常用如下：

- [301 Moved Permanently] 表示永久重定向，用返回的新URL访问。
- [302 Found] 表示临时重定向，请求的资源还在，暂时用另一个URl访问。
- [304 Not Modified] 表示资源未修改，客户端可以使用缓存文件，用于缓存控制。

4xx类状态码表示客户端发送的报文有误，服务器无法处理，常用如下：

- [400 Bad Request] 表示客户端请求的报文有错误，服务器无法处理。
- [401 Unauthorized] 客户端需要对自身进行身份验证。
- [403 Forbidden] 客户端没有访问资源的权限。401服务器不知道客户端身份，但是403知道。
- [404 Not Found] 服务器找不到请求的资源。在403时，服务器也可以返回404，用于对客户端隐藏资源。

5xx类状态码表示客户端请求报文正确，处理时服务器内部发生错误。

- [500 Internal Server Error] 与400类似，是个笼统的错误码。
- [501 Not Implemented] 服务端不支持客户端的请求方法。
- [502 Bad Gateway] 服务器作为网关自身正常工作，但是自身访问的下一个服务器出错。
- [503 Service Unavailable] 表示服务器没准备好处理请求，可能因维护或者重载而停机。

### Case2

#### 题目：什么是强缓存和协商缓存

**答案：**

对于一些重复性的HTTP请求，比如每次请求得到的数据都一样，可以直接把数据缓存在本地，不必通过网络获取服务器的响应，这样HTTP/1.1的性能可以得到提升。
HTTP的缓存实现的方式分为强制缓存和协商缓存。

**强制缓存：**
浏览器如果判断缓存没过期，不发送请求直接使用浏览器本地缓存就是强制缓存。
强制缓存主要由响应头部中的**Cache-Control和Expires**实现。如果头部同时有这两个字段，Cache-Control的优先级比Expires高。

1. 使用**Expires**的强缓存会在Expires字段中设置一个**强缓存时间**，浏览器判断是否过期的方式是读取**本地时间**与Expires字段的时间进行比较。但是如果本地时间与服务器时间不一致时，就会出问题。而且Expires的刷新时间是一秒，在一秒内资源发生变化也会出现问题。
2. 使用**Cache-Control**的强缓存会在字段中设置**max-age**来告知浏览器指定时间内可以使用缓存。与Expires相比，Expires是相对时间，而max-age是绝对时间，不会出现时间不一致的问题。而且服务器每次收到请求，会重新计算资源可以被缓存使用的剩余时间，解决了Expires的两个问题。

**协商缓存：**

HTTP的状态码中有一个是304，作用是告知浏览器可以使用缓存，这种通过**服务端告知客户端**可以使用缓存的方式是协商缓存，也就是通过协商结果判断是否使用本地缓存。也有两种实现方式。

1. 第一种是用请求头部中的**If-Modified-Since字段**和响应头部中的**Last-Modified字段**实现。

   - 使用方法是**服务器发送资源**时会在Last-Modified字段中存储资源最后修改的时间。
   - 当强制缓存资源过期，客户端**再次请求这个资源**时，请求头部中的If-Modified-Since字段值就是收到资源时Last-Modified字段值。
   - **服务器收到请求**看到有If-Modified-Since字段，比较字段值和被请求资源当前的Last-Modified值，如果已经更新，正常返回资源，没有更新则返回304。

   这种方式的两种缺陷：在**没有修改文件内容**时文件的最后修改时间也可能会改变，比如重命名后改回；另外是文件修改时间记录的**最小单位是秒**，如果在几百毫秒内完成修改，文件修改时间并不会改变。

2. 第二种使用请求头部中的**If-None-Match字段**和响应头部的**ETag字段**实现。ETag是根据文件内容计算得到的唯一哈希值。

   - 使用方法是**服务器提供资源**时将ETag和资源一起发给客户端。
   - 强制缓存资源过期，客户端**再次请求**时，会在If-None-Match字段中携带资源的ETag值。
   - 服务器会**比较请求**中的If-None-Match值和当前资源的ETag值，匹配则资源未发生变化，返回304，如果不匹配正常返回资源。

第一次请求资源时，服务端返回的响应头部如果**同时有ETag和Last-Modified字段**，客户端在下一次请求时，如果**也带上了这两个**信息，那么**ETag的优先级更高**。
最后，协商缓存的两个字段都要配合强制缓存中的**Cache-Control字段**来使用，只有**未能命中强制缓存，才能发起带有协商缓存的请求**。

详细内容参考：

[3.1 HTTP 常见面试题 | 小林coding](https://xiaolincoding.com/network/2_http/http_interview.html#http-缓存技术)
[HTTP缓存自述-5分钟了解我的关键历程【前端面试宝典】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1kV4y1K7Rx/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

## Day4

### Case1

#### 题目：HTTP1.0和HTTP1.1的区别

**答案：**

1. **持久连接**：`HTTP/1.0`是短链接，每次请求都要重新建立连接，而一个网页可能需要html、css、js和各种图片文件，请求一个网页会有很多TCP连接断开，并且持久连接要用keep-alive实现，而且不能复用。`HTTP/1.1`默认是长连接的通信方式，也就是持久连接，只要任意一端没有明确提出断开连接，则保持TCP连接状态，减少了重复建立和断开造成的额外开销。

2. **管道化**：`HTTP/1.1`使用持久连接，所以可以使用管道化（不是默认开启），也就是在同一个TCP连接里，客户端可以发起多个请求，只要第一个请求发出去了，**不用等待响应**，就可以发送第二个请求，减少整体的响应时间。但是服务器需要按照**接收请求的顺序发送响应**，如果前面的需求耗时较长，后续的处理会被阻塞。所以HTTP/1.1解决了请求的队头阻塞，但没有解决**响应的队头阻塞**。

3. **缓存控制**：`HTTP/1.0`主要使用If-Modified-Since/Expires来作为缓存判断的标准，`HTTP/1.1`则引入了更多的缓存控制策略，比如ETag/If-None_Match等。

   除了这三点之外`HTTP/1.1`还优化了一些细节的部分。

4. 错误处理：`HTTP/1.1`增加了新的状态码，比如`100 Continue`，用于增强错误处理和请求的中间响应。

5. `Host`头：`HTTP/1.1`新增了`Host`头，允许客户端指定请求的主机，使得一台服务器可以托管多个域名。

6. 局部请求：`HTTP/1.0`中，客户端无法请求资源的一部分，会导致带宽浪费，`HTTP/1.1`在请求头中新增了`range`，允许只请求资源的某个部分，此时返回码是`206（Partial Content）`。

详细内容参考：

[训练营](https://kamacoder.com/training-camp/32)

[3.1 HTTP 常见面试题 | 小林coding](https://xiaolincoding.com/network/2_http/http_interview.html#http-1-1-的性能如何)

### Case2

#### 题目：HTTP2.0与HTTP1.1的区别

**答案：**

1. **头部压缩**：`HTTP/2.0`引入了`HPACK`压缩算法，对请求和响应的头部信息进行压缩。具体操作是在客户端和服务器同时维护一张头信息表，所有发送过的字段都会存入这个表，生成一个索引值，之后对同样的字段只发送索引值。
2. **二进制协议**：`HTTP/1.1`采用了纯文本形式，而`HTTP/2.0`全面采用了二进制格式。头信息和数据体都是二进制，统称为帧：头信息帧和数据帧。增加了数据传输效率。
3. **并发传输**：也就是**多路复用**，`HTTP/1.1`是串行的，完成一个事务之后才能处理下一个事务。`HTTP/2.0`则引出了Stream的概念，一个TCP连接包含多个Stream，Stream里可以包含1个或多个Message，Message对应`HTTP/1.1`中的请求或响应，Message里包含一个或者多个Frame，Frame是`HTTP/2.0`的最小单位。针对不同的请求用Stream ID来区分，接收端可以通过Stream ID有序组装HTTP消息，所以`HTTP/2.0`可以并行交错发送多个请求和响应，但同一个Stream里的顺序是严格的，解决了队头阻塞。
4. **服务器推送**：`HTTP/2.0`允许服务器通过Stream主动推送资源给客户端，这样可以减少页面加载时间。其中客户端的Stream ID必须是奇数，服务器的Stream ID必须是偶数。
5. **优先级和依赖**：`HTTP/2.0`允许客户端为请求设置优先级，并表达请求之间的依赖关系，资源加载更加有序。

详细内容参考：

[3.6 HTTP/2 牛逼在哪？ | 小林coding](https://xiaolincoding.com/network/2_http/http2.html#总结)

[3.1 HTTP 常见面试题 | 小林coding](https://xiaolincoding.com/network/2_http/http_interview.html#http-2-做了什么优化)

### Case3

#### 题目：HTTP3.0有了解过吗

**答案：**

`HTTP/3.0`是HTTP协议的最新版本，基于QUIC协议，具有以下特点：

1. **无队头阻塞**：`HTTP/2.0`虽然基本消除了队头阻塞，但是因为使用TCP协议，如果丢包会触发TCP重传。QUIC协议也有类似`HTTP/2.0`中Stream和多路复用的概念，也可以在同一条连接上并发传输多个Stream，但是他使用`UDP`协议来传输数据，多个Stream之间没有依赖，一个Stream丢包之后，只会阻塞这个Stream，不影响其他Stream，不存在队头阻塞问题。
2. **0RTT连接建立**：`HTTP/1.1`和`HTTP/2.0`中，TCP和TLS是分层的，一个属于传输层，一个属于表示层，难以合并。而`HTTP/3.0`的QUIC协议内部包含了TLS，所以QUIC的帧会携带TLS的记录。QUIC本身握手过程只需要一个RTT，`TLS/1.3`也只需要一个RTT来完成密钥协商，所以两者合并后第一次连接只需要一个RTT。甚至第二次连接时，数据包和握手信息会一起发送，达到0RTT建立连接。
3. **连接迁移**：基于TCP的协议是通过四元组确定一条TCP连接，四元组中包含源IP和目的IP，在网络切换时，IP地址变化就要断开连接。QUIC协议则通过**连接ID**来标记通信的两个端点，实现了连接迁移。
4. 向前纠错机制：每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传。
5. 安全性：`HTTP/3.0`默认使用TLS加密，确保了数据传输的安全性。

详细内容参考：

[3.7 HTTP/3 强势来袭 | 小林coding](https://xiaolincoding.com/network/2_http/http3.html#http-3-协议)

[3.1 HTTP 常见面试题 | 小林coding](https://xiaolincoding.com/network/2_http/http_interview.html#http-3-做了哪些优化)



















