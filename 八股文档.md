# 八股训练营

整理顺序为代码随想录八股训练营题目顺序

## Day1

### Case1

------

#### 题目：介绍一下TCP/IP模型和OSI模型的区别

**答案：**

**1.OSI模型**

OSI模型是国际标准化组织（ISO）制定的一个用于计算机或者通信系统之间互联的标准体系，把计算机网络通信划分为七个不同的层级，每个层级负责特定的功能。每个层级都构建在其下方的层级之上，并且为其上方的层级提供服务。
七层从下到上分别为物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。

**2.OSI模型和TCP/IP模型关系**

OSI模型发布时间比TCP/IP模型早，并且理论上OSI模型更全面，但是实际上TCP/IP模型更加实用，所以目前大多数开发场景都基于TCP/IP模型。

**3.TCP/IP模型**

TCP/IP模型分为四层，下面从上到下进行介绍。

**应用层：**
最上层是应用层，这一层与OSI模型的应用层、表示层和会话层相似，提供直接与用户程序交互的接口，比如电子邮件（SMTP）、网页浏览（HTTP）、文件传输（FTP）等。

各种计算机系统的应用软件都是在应用层实现的，两个不同设备的应用需要通信时，应用层就把数据传给下一层，并不关心数据是如何传输的。

（回答时候去掉：应用层工作在操作系统的用户态，传输层及一下工作在内核态。）

**传输层：**
应用层下面是传输层，该层对应OSI模型的传输层，负责在端到端的数据传输时提供传输服务。

主要有两个传输协议，TCP和UDP。TCP提供可靠的数据传输，确保了数据的正确性和完整性。UDP则是无连接的、不可靠的，实时性更好，效率更高，适用于不要求可靠性的传输，比如实时音频和视频流。

**网络层：**
传输层下面是网络层，该层对应OSI模型的网络层。传输层听起来像是负责把数据从一个设备传输到另一个设备，事实上这部分是由网络层负责的，传输层的功能是服务好应用层，也就是打包和接收数据。

网络层的常用协议是IP协议，主要作用是寻址和路由，用IP地址标识源主机和目标主机，用路由来选择最佳路径传输数据。

**网络接口层：**
网络层下面是网络接口层，该层对应OSI模型的数据链路层和物理层。

网络层只负责网络层级的传输，网络接口层则负责这个层级之下物理传输媒介的传输，比如以太网、WiFi等。这个层级使用MAC地址标识网络上的设备，所以网络接口层包含对MAC地址的管理，也有错误检测和纠错功能。

详细内容参考：[2.1 TCP/IP 网络模型有哪几层？ | 小林coding](https://xiaolincoding.com/network/1_base/tcp_ip_model.html#应用层)

### Case2

------

#### 题目：从输入URL到页面展示到底发生了什么？

**答案：**

**第一步**是浏览器对URL进行解析，生成发送给Web服务器的请求信息。

**第二步**是查询得到服务器域名对应的IP地址。查询的顺序是浏览器缓存，操作系统缓存，host文件，路由器缓存，本地DNS服务器。这部分都是客户端在访问，之后如果本地DNS服务器没有IP信息，本地DNS服务器会依次访问根DNS服务器，顶级DNS服务器，权威DNS服务器，最后从权威DNS服务器得到IP地址返回给客户端。

**第三步**，有了IP地址之后，浏览器与服务器IP三次握手建立TCP连接。

**第四步**，将第一步得到的http报文依次包上TCP头部、IP头部、MAC头部，其中还会包含和该域名相关的Cookie等数据，然后浏览器就会将请求发出。如果是HTTPS的话，还要涉及到HTTPS的加密解密流程。

**第五步**，请求发出之后，会依次经过网卡、交换机、路由器等设备，最终到达目标IP。这个过程中的MAC头部会不断的变化，但是源IP和目的IP一直不会改变。

**第六步**，服务器接收到请求，一层层解析头部，同时判断这个请求是否是发给自己的，如果是发给自己的，根据请求生成响应数据。

**第七步**，TCP四次挥手断开连接，浏览器和服务器IP断开TCP连接。

**第八步**，浏览器解析响应数据并渲染页面。

下面这部分是拓展，考官问了说。

- 浏览器解析响应头。若响应头状态码为301、302，会重定向到新地址；若响应数据类型是字节流类型，一般会将请求提交给下载管理器；若是HTML类型，会进入下一部渲染流程。
- 浏览器解析HTML文件，创建DOM树，解析CSS进行样式计算，然后将CSS和DOM合并，构建渲染树；最后布局和绘制渲染树，完成页面展示。

详细内容参考：[2.2 键入网址到网页显示，期间发生了什么？ | 小林coding](https://xiaolincoding.com/network/1_base/what_happen_url.html)

## Day2

### Case1

#### 题目：HTTP请求报文和响应报文是怎样的，有哪些常见的字段？

**答案**：

HTTP报文分为请求报文和响应报文

**请求报文**主要由**请求行、请求头部、空行和请求数据**四个部分组成。
**请求行**由**请求方法、URI和HTTP协议版本**三个字段组成，每个字段之间用空格隔开，最后一个字段后面跟回车符和换行符。
**请求方法**有以下几种：HTTP1.0定义了GET、POST和HEAD三种方法，HTTP1.1新增了OPTIONS、PUT、PATCH、DELETE、TRACE和CONNECT六种方法。
**请求头部**字段常见的有：

- Accept：客户端能够处理的媒体类型。
- Accept-Encoding：客户端能够解码的内容编码方式，比如gzip。
- Accept-Language：客户端所希望的语言种类，在服务器能够提供一种以上的语言版本时需要。
- Authorization：用于认证的凭证信息，比如token数据。
- Content-Type：请求体的媒体类型。
- Content-Length：请求体的长度。
- Host：客户端要访问的服务器域名。
- User-Agent：包含发出请求的用户信息，客户端类型。
- Cookie：存储在客户端的cookie数据。
- Connection：管理连接的选项，比如keep-alive。
- If-None-Match：资源的ETag值，用于缓存控制。

请求头部之后是**空行**，用于告知服务器请求头部到此为止。
在空行之后是**请求数据**，如果方法字段是GET，那么这一项为空，如果是方法字段是POST，请求数据是要提交的数据，比如我要登录服务器，这部分就会放置username和password。

**响应报文**是服务器向客户端返回的数据格式，用于传达服务器对客户端请求的处理结果和相关数据。主要由**状态行、响应头部、空行和响应正文**四个部分组成。
**状态行**由**协议版本、状态码和原因短语**组成，每个字段由空格隔开，其中原因短语是可选的。最后也跟回车符和换行符。
**响应头部**字段常见的有：

- Allow：服务器支持哪些请求方法。
- Content-Encoding：文档的编码方法。
- Content-Length：响应正文的长度。
- Content-Type：响应正文的媒体类型。
- Date：当前的GMT时间。
- Location：该字段会配合302状态码使用，重定向到一个新的URI地址。
- Server：指定服务器的信息。
- Set-Cookie：设置与页面关联的Cookie。
- Last-Modified：资源最后被修改的日期和时间。
- Expires：响应的过期时间，之后的内容被认为是过时的。
- ETag：响应体的实体标签，用于缓存和条件请求。
- Access-Control-Allow-Origin: 跨源资源共享（CORS）策略，指示哪些域可以访问资源。

响应头部之后也是一个**空行**，用于告知响应头部结束了。

最后是**响应正文**，是服务端实际传输的数据，可以是文本、HTML页面、图片、视频等，也可以是空。

详细内容参考：

[训练营](https://kamacoder.com/training-camp/32)

[3.2.5 HTTP_1.1请求报文格式_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1gg4y1P7Yt/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

[3.2.6 HTTP_1.1响应报文格式_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Sm4y1J7dr/?share_source=copy_web&vd_source=9bb0aa9c2c3cc1b12ca6f343a55b4e80)

### Case2

#### 题目：HTTP有哪些请求方式？

**答案：**

| 序号 | 方法    | 描述                                                         |
| ---- | ------- | ------------------------------------------------------------ |
| 1    | GET     | 请求从服务器获取一个资源                                     |
| 2    | POST    | 向指定资源提交数据进行处理请求，比如提交表单                 |
| 3    | HEAD    | 请求一个与GET请求相同的响应，但是没有响应体，用于检查资源的元数据 |
| 4    | PUT     | 发送数据以更新现有资源，如果资源不存在则创建新的资源         |
| 5    | DELETE  | 删除指定的资源                                               |
| 6    | PATCH   | 对资源进行部分修改，PUT是整个替换，PATCH是修改部分           |
| 7    | OPTIONS | 查询服务器支持的请求方法                                     |
| 8    | TRACE   | 对到目标资源的路径进行环回测试，主要用于诊断                 |
| 9    | CONNECT | 建立一个到服务器的隧道，常用于HTTPS连接                      |

详细内容参考：

[HTTP 请求方法 - HTTP | MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods)

[HTTP 请求方法 | 菜鸟教程](https://www.runoob.com/http/http-methods.html)

### Case3

#### 题目：GET请求和POST请求的区别

**答案：**

按照RFC规范分析，两者主要有以下区别：

- 语义：GET是从服务器获取指定资源，POST是根据请求负荷对指定的资源作出处理。
- 参数：GET参数一般写在URL中，并且只支持ASCII字符，浏览器对URL的长度会有限制。POST携带的数据一般写在报文body中，支持任意格式，理论上没有长度限制。
- 安全性：针对服务器的安全来说，GET属于“只读”类型，不会修改服务器数据，是安全的，POST会修改数据，对服务器不安全。针对数据泄露的安全来说，GET的数据直接暴露在URL中，而POST的数据在HTTP协议下可以通过抓包得到，两者都不太安全。
- 幂等：GET因为是“只读”的，所以他是幂等的，而POST每次提交都可能修改数据或者创建资源，不是幂等的。
- 缓存：GET请求可以被缓存，而POST默认不会被缓存。

详细内容参考：

[3.1 HTTP 常见面试题 | 小林coding](https://xiaolincoding.com/network/2_http/http_interview.html#get-与-post)

[GET - HTTP | MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET)

[POST - HTTP | MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST)

## Day3

### Case1

#### 题目：HTTP中常见的状态码有哪些？

**答案：**

### Case2

#### 题目：什么是强缓存和协商缓存

**答案：**

对于一些重复性的HTTP请求，比如每次请求得到的数据都一样，可以直接把数据缓存在本地，不必通过网络获取服务器的响应，这样HTTP/1.1的性能可以得到提升。
HTTP的缓存实现的方式分为强制缓存和协商缓存。

**强制缓存：**
浏览器如果判断缓存没过期，不发送请求直接使用浏览器本地缓存就是强制缓存。
强制缓存主要由响应头部中的**Cache-Control和Expires**实现。如果头部同时有这两个字段，Cache-Control的优先级比Expires高。

1. 使用**Expires**的强缓存会在Expires字段中设置一个**强缓存时间**，浏览器判断是否过期的方式是读取**本地时间**与资源中的Expires字段的时间进行比较。这样子有个问题，就是本地时间与服务器时间不一致时，就会出问题。而且Expires的刷新时间是一秒，在一秒内资源发生变化也会出现问题。
2. 使用**Cache-Control**的强缓存会在字段中设置**max-age**来告知浏览器指定时间内可以使用缓存。与Expires相比，Expires是相对时间，而max-age是绝对时间。而且服务器每次收到请求，会重新计算资源可以使用缓存的剩余时间，解决了Expires的两个问题。

**协商缓存：**

HTTP的状态码中有一个是304，作用是告知浏览器可以使用缓存，这种通过**服务端告知客户端**可以使用缓存的方式是协商缓存，也就是通过协商结果判断是否使用本地缓存。也有两种实现方式。

1. 第一种是用请求头部中的**If-Modified-Since字段**和响应头部中的**Last-Modified字段**实现。

   - 使用方法是**服务器发送资源**时会在Last-Modified字段中存储资源最后修改的时间。
   - 当强制缓存资源过期，客户端**再次请求这个资源**时，请求头部中的If-Modified-Since字段值就是收到资源时Last-Modified字段值。
   - **服务器收到请求**看到有If-Modified-Since字段，比较字段值和被请求资源当前的Last-Modified值，如果已经更新，正常返回资源，没有更新则返回304。

   这种方式的两种缺陷：在**没有修改文件内容**时文件的最后修改时间也可能会改变，比如重命名后改回；另外是文件修改时间记录的**最小单位是秒**，如果在几百毫秒内完成修改，文件修改时间并不会改变。

2. 第二种使用请求头部中的**If-None-Match字段**和响应头部的**ETag字段**实现。ETag是根据文件内容计算得到的唯一哈希值。

   - 使用方法是**服务器提供资源**时将ETag和资源一起发给客户端。
   - 强制缓存资源过期，客户端**再次请求**时，会在If-None-Match字段中携带资源的ETag值。
   - 服务器会**比较请求**中的If-None-Match值和当前资源的ETag值，匹配则资源未发生变化，返回304，如果不匹配正常返回资源。

第一次请求资源时，服务端返回的响应头部如果**同时有ETag和Last-Modified字段**，客户端在下一次请求时，如果**也带上了这两个**信息，那么**ETag的优先级更高**。
最后，协商缓存的两个字段都要配合强制缓存中的**Cache-Control字段**来使用，只有**未能命中强制缓存，才能发起带有协商缓存的请求**。